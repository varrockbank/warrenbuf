WarrenBuf is an overpowered plaintext buffer for the web, managing billions^{[1]} of lines without bottleneck. It's ~3KB /(gzip+min)/ and zero-dependency but punches above its weight with editor features.

[[resources/preview.png]]

[[https://varrockbank.github.io/warrenbuf/][Live Demo]] ( Tree-sitter disabled in demo )

[[https://varrockbank.github.io/warrenbuf/test/][Interactive Test Playground]] 

[1]: /~128GB RAM and chunking in large files up to the max string length for delimiting on '\n'. The main point is that capacity scales ~O(n) of RAM, with minimal overhead, and user interaction doesn't become sluggish. Compare with libraries that dumps the entire sourcetext to <textarea> or DOM and becomes unresponsive by ~O(100,000) lines./

** Ethos

*Avoid JS fatigue:* no compilation, no NPM, no building. Simply vendor the VanillaJS function.

*Inspired by vim:* minimal, capable, fast

*Embedded:*  the features and tiny footprint uniquely positions this project to be a building block for larger apps (e.g. IDEs and other enriched plaintext environments). In fact, this is heuristic in scoping features. The endstate of this warrenbuf is to be barebones and let complex editor logic be built on top of it. 

** How? 

At its core, WarrenBuf is a rendering engine. In fact, it started out as read-only log viewer and no editing capabilities. Its innovation is a technique loaned from game dev: clipping. i.e. render a Viewport containing only the source lines in view. There's always a small fixed set of elements to update. This sidesteps the DOM bottleneck. 

Arrays are the dark horse of text editor data structures — inefficient for common editing operations since they involve shifting line numbers. This project embraces the fact that it’s web-bound, leaning on V8 for the computer-science heavy lifting. JavaScript’s array-like performance rival far more complex rope or piece-table structures while staying true to the problem domain. Consider that Monaco's robust piece table implementation is more than 10x WarrenBuf's entire footprint. 

** Usage 

Editor instances are instantiated by specifying a DOM node having the following template 

#+begin_src html
<blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="playground">
  <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
  <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
    </div>
  </div>
</blockquote>
const editorInstance = new WarrenBuf(document.getElementById("playground"));
#+end_src

It was decided against WarrenBuf creating this DOM structure. 

*** Model-view-controller

The API is on the editor instance. There are three main constructs: 

*Model* =instance.Model.lines= is the text buffer 

*View* =instance.Viewport= is the subset of the text buffer to be rendered 

*Controller* =instance.Selection= defines text editor operations relative to the text Selection. Cursor are just a special case of Selection.

** Extensibility 

Extensibility is currently achieved by the MVC APIs. 

iOS support is currently provided as an extension which maps iOS events to keyboard events. see: index.html for example. 

Tree-sitter support is still experimental. Integration is tightly coupled until the right abstraction is solidified. Likely, the WarrenBuf core will be agnostic to custom rendering and simply ask for a callback to generate HTML. At that point Tree-sitter can be made an extension.

** Distributable

There is no build process needed to vendor WarrenBuf global function. However, the minified distributable is created with Terser. This is done by a pre-commit hook ensuring dist/warrenbuf.min.js is updated in sync. Symlink to git: 

#+begin_src sh
ln -s ../../hooks/pre-commit .git/hooks/pre-commit
#+end_src

To test the hook manually without creating a commit:

#+begin_src sh
./hooks/pre-commit
#+end_src

** Why? 

This section discusses why Warrenbuf exists and its competitive advantage.

Monaco is bloated. Ace is great but 10x larger and still not barebones enough. Libraries in the same weigh class as WarrenBuf are not suitable for performant plaintext editor experiences on top of.

*** =<textarea>=

"<textarea>" is semantically meaning HTML but its purpose is for editing small snippets of monospace/"preformatted" text. The fundamental feature of a text editor is editing non-trivial sized documents. Heck, it's so important that we don't even think of this as a "feature". Editors that can't do so are effectively useless. =<textarea>= is DOM bound and several thousand lines is enough for it to be sluggish. 

Beyond small file sizes, there are other hard-coded behaviors of =<textarea>= that is not conducive to creating customizable editor experience. For example, defining the behavior of cursor/selections or line numbers beyond what W3C and browser implementers have decided. =<textarea>= has been here since the beginning of time and browser idiosyncracies are one of many idiosyncracies. 

It's possibe to override one or two of =<textarea>='s default behavior but now you're re-implementing a new textarea with all of the old baggage. i.e. the second system effect. Testing for consistency in browser support also complexifies things. 

In brief, =<textarea>= is idiosyncratic, inflexible and low-capacity. 

*** <textarea>-based libraries

Libraries in the same weight class as WarrenBuf achieve a small footprint by being clever codegolf hacks of =<textarea>=. This means they are restrictive in their functionalities they add. These solutions put lipstick on a pig and is a non-starter for anything beyond a toy.

Granted, these libraries are focused on the WYSIWYG case rather than plaintext editing.

*** Monaco

Monaco, the web counterpart of VSCode, is a powerhouse but with a 10000x larger footprint. It doesn't fit in a floppy disk much less the initial 14KB TCP window.

It is overkill in the vast majority of cases that involve a custom editor experience. see: "Rant on Monaco-based apps"

*** C++ buffer management via WebAssembly

Early experiments involved a delegating buffer management to a WASM module written in C++. It's the anthropic principle that WarrenBuf uses VanillaJS V8+ Arrays today.

There is overhead to the JS<->WASM boundary crossing. It was significant but just below the level of human perception. The threshold was quickly surpassed with time spent in WASM-land. Rolling handwritten datastructures in C++ or other native code that outperforms V8 optimizations is difficult. A lot of engineering/witchcraft went into V8 and it shows. I gladly await someone else implement an efficient text buffer management and editor engine exposed as a WASM module.

The WASM toolchain still felt like "death by a thousand cuts". All things considered, it is more pleasant to work with VanillaJS.

*** Leveraging the web platform

The DOM is slow. Other text editor libraries mount the entire source text to the DOM. 10^5 elements can be enough to make the browser tab unresponsive. WarrenBuf loans the technique of "clipping" from graphics programming to render only the segment of the world that are in view. aside: occlusion culling extends this idea.

V8 is brilliant. Premier text editors use ropes, gap buffers, piece tables, and some combination in between to achieve performance. These data structures are hard to get right and their sourcecode is necessarily complex. A naive array implementation is intuitive as it matches the problem domain of indexed lines of text. Arrays are infeasible because text editor operations including line deletes and additions involve O(n) shifts. JavaScript Arrays are not actual arrays. V8 handles splices, the generalization of shift, instantaneously for even the largest of buffers. For once the web platform is a development luxury where we can have cake and eat it too. WarrenBuf reaps the simplicity of arrays without sacrificing performance.

*** Surgical DOM rendering

WarrenBuf couples buffer state with surgical DOM updates. The endstate of the project is towards updating only the DIFFed DOM segments. This is idealistic because redundancy in cheap DOM updates may be preferable to the overhead of corner-case management having too many branching pathways.

It's virtuous that WarrenBuf remain a microlibrary. The webdev Zeitgest is a declarative library that reactively alter DIFFs/changed subtrees. This does not come free. A trustworthy barebones React-like library is larger than WarrenBuf in its entirety. UI libraries are useful for managing a complex UI with a large component tree where it is impossible to manage otherwise. WarrenBuffer's minimalism culminates in a handful of visual elements and a dozen operations. In this scenario, a few precision DOM mutations is superior to the overhead of a presumably smart and efficient DOM rendering library, especially as the DIFFs do not involve "complete"/full trees. WarrenBuffer's adhoc rendering avoids introducing a dependency, managing a state tree, run a change-tracking loop, defining a declarative DSL, merging in a virtual DOM tree, smoothing-out browser compatibility, needing a build process or other complexities, The surface space is small enough to reasonably expect WarrenBuffer's implementer carefully consider the effects of every operation. Plus, it's fun being close to the "DOM metal"

Correctness is prioritized over performance micro-optimizations. Currently, there may be cases where the entire viewport is unnecessarily refreshed. For all intensive purposes this will not be detectable by the user. O(c) where c=30 surgical line updates is trivial compared to maintaining even the smallest of virtual DOM trees.

One optimization pattern currently deployed is (re)using document fragments for batch inserts. This minimizes DOM mutations/operations.

*** VSCode's Buffer Management

In 2022, VSCode would choke on 10^7 LoC (50MB) files, becoming unresponsive for up to a minute while loading them into memory.

VSCode had already adopted a Piece Table combined with a balanced tree (see: https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation).

By September 2025, VSCode appears to have fixed this bottleneck by detecting large files, short-circuiting preprocessing, and defaulting to plaintext editing. The issue may have been in syntax highlighting rather than buffer management—=vim= proves it's feasible to syntax highlight much larger files.

VSCode's text buffer implementation is available at https://github.com/microsoft/vscode-textbuffer/tree/main. At ~50KB it's acceptable, though 50x WarrenBuf's footprint.

Monaco, the web version of VSCode, follows the same implementation and has similar performance characteristics.

*** Rant on Monaco-based apps

VSCode provides an impressive, professional-looking product out-of-the-box without custom code. Most VSCode-based apps don't even bother reskinning themselves. It's a disservice to Dota (a mod of Warcraft III) to call these "VSCode mods"—they aren't modifying anything, just providing their own config file. In effect, they ARE VSCode paired with a custom backend.

Perhaps there's a business opportunity for VSCode-as-a-service where tenants bring their own config and data. This would cache the VSCode bundle once across apps instead of requiring a heavy download for each. Perhaps this doesn't exist because it would reveal how little value most tenants add on the frontend.

Most VSCode-based apps appear lazy and careless toward software craftsmanship. It's disrespectful to end users who suffer loading a bloated editor with irrelevant "features" that weren't tree-shaken away.

*** Ace Editor

Ace Editor stands out. Per their README (September 2025): "Handles huge documents (at last check, 4,000,000 lines is the upper limit)". This is orders magnitude better than the microlibraries in WarrenBuf's weight class. 

It's a respectable library for building editor experiences. I'd recommend it.

The codebase is also praiseworthy. Unavoidably, Ace carries legacy and compatibility baggage. It includes bells and whistles that, unless tree-shakeable, make it bloated compared to WarrenBuf. WarrenBuf enjoys the privilege of starting from a clean slate in 2025.

Note that Ace instantiates a hidden =<textarea>= around the user's cursor to bind keyboard input. This isn't the same as a textarea for the entire source text—otherwise Ace would suffer the same bottlenecks as other editor libraries. Performance issues with =<textarea>= are less pronounced in Ace's approach. One caveat with Ace's "culled" textarea: large selections require proportionally large textareas, reintroducing the DOM bottleneck. WarrenBuf avoids this with virtual cursors.
