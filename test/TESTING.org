* Overview

WarrenBuf uses a native browser-based test suite with no dependencies on Jest or NPM.

* Running Tests

Open ~test.html~ in your browser. Tests run automatically on page load.

* Interactive Walkthrough

Each test includes a *Walkthrough* button that opens an interactive step-by-step debugger:

- *Left panel*: Test source code with inline step markers and expect highlighting
- *Right panel*: Live WarrenBuf editor showing the test execution
- *Step navigation*: Previous/Next buttons to replay test actions one at a time

** How it works

1. Click the "Walkthrough" button on any test
2. Use Next/Previous buttons to step through the test execution
3. Watch the editor state update in real-time on the right panel
4. Expect statements are highlighted green (✓) or red (✗) as you step past them
5. Step markers (1, 2, 3...) show which walkthrough step maps to which code line

The walkthrough replays the exact same actions recorded during the test run, providing a visual debugging experience.

* Directory Structure

- *test.html* - Test runner UI with results display and interactive walkthrough panel
- *test-framework.js* - Domain-agnostic test library with ~describe~, ~it~, ~xit~, ~expect~
- *harness.js* - Test harness providing (1) literate DSL for user actions and (2) step recording for walkthrough replay
- *expect.js* - Assertion matchers with special support for EditorTestHarness
- *test.spec.js* - All test definitions

* Writing Tests

** Basic Structure

#+begin_src javascript
runner.describe('Feature Name', () => {
  let fixture;

  runner.beforeEach(() => {
    fixture = new EditorTestHarness();
  });

  runner.it('should do something', () => {
    fixture.type('Hello');
    fixture.press(Key.Enter).once();

    expect(fixture.wb.Model.lines[0]).toBe('Hello');
  }, "Optional description");
});
#+end_src

** Test Isolation

Each test gets a *fresh DOM node and WarrenBuf instance* via ~new EditorTestHarness()~. This ensures proper test isolation with no state leakage between tests.

** EditorTestHarness & Literate DSL

The test harness serves three purposes:

1. *Test isolation* - Provides an isolated editor instance (DOM node + WarrenBuf) for each test
2. *Test execution* - Drives the editor with a literate DSL for user actions
3. *Step recording* - Captures all actions as metadata for interactive walkthrough replay

The harness provides a literate, chainable DSL that reads like user actions:

#+begin_src javascript
// Create harness
const fixture = new EditorTestHarness();

// Access WarrenBuf instance and DOM node
fixture.wb    // WarrenBuf instance
fixture.node  // DOM node

// Type text
fixture.type('Hello World');

// Press keys with modifiers (chainable builder pattern)
fixture.press(Key.Enter).once();
fixture.press(Key.Backspace).times(3);
fixture.press(Key.ArrowLeft).withMetaKey().once();
fixture.press(Key.ArrowRight).withShiftKey().once();
fixture.press(Key.ArrowDown).withShiftKey().withMetaKey().once();
fixture.press(' ').once();  // Single character key
#+end_src

All actions are automatically recorded to ~fixture.steps~ as metadata, enabling step-by-step replay in the interactive walkthrough UI.

** Available Key Constants

#+begin_src javascript
Key.Enter
Key.Backspace
Key.ArrowLeft
Key.ArrowRight
Key.ArrowUp
Key.ArrowDown
#+end_src

** DSL Design Principles

- *Deferred execution*: Modifiers chain, execution happens on ~.once()~ or ~.times(n)~
- *Literate syntax*: Reads like natural user actions
- *Type safety*: Validates key names (single chars or Key constants only)

** Assertions

The test framework provides basic assertions:

#+begin_src javascript
expect(value).toBe(expected)           // Strict equality
expect(value).toEqual(expected)        // Deep equality (JSON)
expect(array).toHaveLength(3)          // Array/string length
#+end_src

** Testing Model State

#+begin_src javascript
// Check text content
expect(fixture.wb.Model.lines[0]).toBe('Hello');
expect(fixture.wb.Model.lines).toHaveLength(2);
#+end_src

** Testing Cursor/Selection

#+begin_src javascript
// Get cursor position (firstEdge and SecondEdge are same for cursor)
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 5 });
expect(SecondEdge).toEqual({ row: 0, col: 5 });

// Check if selection exists
expect(fixture.wb.Selection.isSelection).toBe(true);

// Selection positions
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 0 });  // Start of selection
expect(SecondEdge).toEqual({ row: 0, col: 5 });  // End of selection
#+end_src

** Skipping Tests

Use ~xit~ instead of ~it~ to skip a test:

#+begin_src javascript
runner.xit('should do something later', () => {
  // This test won't run
}, "Description");
#+end_src

* Test Suites

** Basic Typing
- Single character insertion
- Multiple character insertion
- Typing with spaces

** Backspace
- Delete single/multiple characters
- Delete all characters

** Enter Key
- Create new lines
- Split lines at cursor

** Complex Sequences
- Mixed operations (type, delete, retype)
- Multi-line editing
- Delete across line boundaries

** Selection
- Shift+Arrow navigation
- Multi-line selection
- Forward/backward selection

** Cursor Movement - Varying Line Lengths
- Column preservation with maxCol
- Clamping to shorter lines
- Restoring column position

* Understanding the Cursor Model

- Cursor position is a *fencepost* - it sits between characters
- ~row~ and ~col~ are viewport-relative (not absolute line numbers)
- After typing "Hello", cursor is at col 5 (one past the last 'o')
- Lines are implicitly delimited by ~\n~ (not stored in Model.lines)
- To delete a newline, cursor must be at the start of the next line

** maxCol Behavior

~maxCol~ preserves the intended column when moving vertically:

1. Type "Long line here" → cursor at col 14, maxCol = 14
2. ArrowDown to shorter line "Hi" → cursor clamped to col 2
3. ArrowDown to another long line → cursor restores to col 14 (using maxCol)

This matches vim/VSCode behavior for vertical navigation.
