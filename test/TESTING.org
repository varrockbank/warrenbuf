* Overview

WarrenBuf uses a native browser-based test suite with no dependencies on Jest or NPM.

* Running Tests

Open ~test.html~ in your browser. Tests run automatically on page load.

* Directory Structure

- *test.html* - Test runner UI with results display
- *test-framework.js* - Domain-agnostic test library with ~describe~, ~it~, ~xit~, ~expect~
- *dsl.js* - Fixture to (1) isolate test state and (2) literate DSL for user actions. 
- *test.spec.js* - All test definitions

* Writing Tests

** Basic Structure

#+begin_src javascript
runner.describe('Feature Name', () => {
  let fixture;

  runner.beforeEach(() => {
    fixture = new EditorFixture();
  });

  runner.it('should do something', () => {
    fixture.type('Hello');
    fixture.press(Key.Enter).once();

    expect(fixture.wb.Model.lines[0]).toBe('Hello');
  }, "Optional description");
});
#+end_src

** Test Isolation

Each test gets a *fresh DOM node and WarrenBuf instance* via ~new EditorFixture()~. This ensures proper test isolation with no state leakage between tests.

** EditorFixture & Literate DSL

The test fixture provides a literate, chainable DSL that reads like user actions:

#+begin_src javascript
// Create fixture
const fixture = new EditorFixture();

// Access WarrenBuf instance and DOM node
fixture.wb    // WarrenBuf instance
fixture.node  // DOM node

// Type text
fixture.type('Hello World');

// Press keys with modifiers (chainable builder pattern)
fixture.press(Key.Enter).once();
fixture.press(Key.Backspace).times(3);
fixture.press(Key.ArrowLeft).withMetaKey().once();
fixture.press(Key.ArrowRight).withShiftKey().once();
fixture.press(Key.ArrowDown).withShiftKey().withMetaKey().once();
fixture.press(' ').once();  // Single character key
#+end_src

** Available Key Constants

#+begin_src javascript
Key.Enter
Key.Backspace
Key.ArrowLeft
Key.ArrowRight
Key.ArrowUp
Key.ArrowDown
#+end_src

** DSL Design Principles

- *Deferred execution*: Modifiers chain, execution happens on ~.once()~ or ~.times(n)~
- *Literate syntax*: Reads like natural user actions
- *Type safety*: Validates key names (single chars or Key constants only)

** Assertions

The test framework provides basic assertions:

#+begin_src javascript
expect(value).toBe(expected)           // Strict equality
expect(value).toEqual(expected)        // Deep equality (JSON)
expect(array).toHaveLength(3)          // Array/string length
#+end_src

** Testing Model State

#+begin_src javascript
// Check text content
expect(fixture.wb.Model.lines[0]).toBe('Hello');
expect(fixture.wb.Model.lines).toHaveLength(2);
#+end_src

** Testing Cursor/Selection

#+begin_src javascript
// Get cursor position (firstEdge and SecondEdge are same for cursor)
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 5 });
expect(SecondEdge).toEqual({ row: 0, col: 5 });

// Check if selection exists
expect(fixture.wb.Selection.isSelection).toBe(true);

// Selection positions
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 0 });  // Start of selection
expect(SecondEdge).toEqual({ row: 0, col: 5 });  // End of selection
#+end_src

** Skipping Tests

Use ~xit~ instead of ~it~ to skip a test:

#+begin_src javascript
runner.xit('should do something later', () => {
  // This test won't run
}, "Description");
#+end_src

* Test Suites

** Basic Typing
- Single character insertion
- Multiple character insertion
- Typing with spaces

** Backspace
- Delete single/multiple characters
- Delete all characters

** Enter Key
- Create new lines
- Split lines at cursor

** Complex Sequences
- Mixed operations (type, delete, retype)
- Multi-line editing
- Delete across line boundaries

** Selection
- Shift+Arrow navigation
- Multi-line selection
- Forward/backward selection

** Cursor Movement - Varying Line Lengths
- Column preservation with maxCol
- Clamping to shorter lines
- Restoring column position

* Understanding the Cursor Model

- Cursor position is a *fencepost* - it sits between characters
- ~row~ and ~col~ are viewport-relative (not absolute line numbers)
- After typing "Hello", cursor is at col 5 (one past the last 'o')
- Lines are implicitly delimited by ~\n~ (not stored in Model.lines)
- To delete a newline, cursor must be at the start of the next line

** maxCol Behavior

~maxCol~ preserves the intended column when moving vertically:

1. Type "Long line here" → cursor at col 14, maxCol = 14
2. ArrowDown to shorter line "Hi" → cursor clamped to col 2
3. ArrowDown to another long line → cursor restores to col 14 (using maxCol)

This matches vim/VSCode behavior for vertical navigation.
