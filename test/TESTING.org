* Overview

WarrenBuf uses a native browser-based test suite with no dependencies on Jest or NPM.

* Running Tests

Open ~index.html~ in your browser. Tests run automatically on page load.

Specs can be ad-hocly modified under the ~source~ tab and tests re-ran after compilation.

* Interactive Walkthrough

Each test includes a *Walkthrough* button that opens an interactive step-by-step debugger:

- *Left panel*: Test source code with inline step markers and expect highlighting
- *Right panel*: Live WarrenBuf editor showing the test execution
- *Step navigation*: Previous/Next buttons to replay test actions one at a time

** How it works

1. Click the "Walkthrough" button on any test
2. Use Next/Previous buttons to step through the test execution
3. Watch the editor state update in real-time on the right panel
4. Expect statements are highlighted green (✓) or red (✗) as you step past them
5. Step markers (1, 2, 3...) show which walkthrough step maps to which code line

The walkthrough replays the exact same actions recorded during the test run, providing a visual debugging experience.

* Directory Structure

- *specs.dsl* - All test definition
- *index.html* - Test runner. Loads specs from specs.dsl

index.html uses scripts from *lib/* 

- *lib/test-framework.js* - Domain-agnostic test library with ~describe~, ~it~, ~xit~, ~expect~
- *lib/harness.js* - Test harness providing (1) literate DSL for user actions and (2) step recording for walkthrough replay
- *lib/expect.js* - Assertion matchers with special support for EditorTestHarness
- *lib/walkthrough.js* - Implements the test walkthrough UI
- *lib/vs2015.min.css*, *lib/highlight.min.js* - syntax highlighting for UI 
- *dsl/transpiler.js* - Transpiles DSL to JavaScript

* Writing Tests

** Basic Structure

#+begin_src javascript
runner.describe('Feature Name', () => {
  let fixture;

  runner.beforeEach(() => {
    fixture = new EditorTestHarness();
  });

  runner.it('should do something', () => {
    fixture.type('Hello');
    fixture.press(Key.Enter).once();

    expect(fixture.wb.Model.lines[0]).toBe('Hello');
    expect(fixture).toHaveCursorAt(1, 2);
  }, "Optional description");
});
#+end_src

The corresponding DSL is 

#+begin_src javascript
# Feature name
## should do someting 
### Optional description
TYPE "HELLO"
enter
expect(fixture).toHaveLines('a');
EXPECT cursor at 1,2 
#+end_src

** Test Isolation

Each test gets a *fresh DOM node and WarrenBuf instance* via ~new EditorTestHarness()~. This ensures proper test isolation with no state leakage between tests.

** EditorTestHarness & Literate DSL

The test harness serves three purposes:

1. *Test isolation* - Provides an isolated editor instance (DOM node + WarrenBuf) for each test
2. *Test execution* - Drives the editor with a literate DSL for user actions
3. *Step recording* - Captures all actions as metadata for interactive walkthrough replay

The harness provides a literate, chainable DSL that reads like user actions:

#+begin_src javascript
// Create harness
const fixture = new EditorTestHarness();

// Access WarrenBuf instance and DOM node
fixture.wb    // WarrenBuf instance
fixture.node  // DOM node

// Type text
fixture.type('Hello World');

// Press keys with modifiers (chainable builder pattern)
fixture.press(Key.Enter).once();
fixture.press(Key.Backspace).times(3);
fixture.press(Key.ArrowLeft).withMetaKey().once();
fixture.press(Key.ArrowRight).withShiftKey().once();
fixture.press(Key.ArrowDown).withShiftKey().withMetaKey().once();
fixture.press(' ').once();  // Single character key
#+end_src

All actions are automatically recorded to ~fixture.steps~ as metadata, enabling step-by-step replay in the interactive walkthrough UI.

** Available Key Constants

#+begin_src javascript
Key.Enter
Key.Backspace
Key.ArrowLeft
Key.ArrowRight
Key.ArrowUp
Key.ArrowDown
#+end_src

** DSL Design Principles

- *Deferred execution*: Modifiers chain, execution happens on ~.once()~ or ~.times(n)~
- *Literate syntax*: Reads like natural user actions
- *Type safety*: Validates key names (single chars or Key constants only)

** Assertions

The test framework provides basic assertions:

#+begin_src javascript
expect(value).toBe(expected)           // Strict equality
expect(value).toEqual(expected)        // Deep equality (JSON)
expect(array).toHaveLength(3)          // Array/string length
#+end_src

** Testing Model State

#+begin_src javascript
// Check text content
expect(fixture.wb.Model.lines[0]).toBe('Hello');
expect(fixture.wb.Model.lines).toHaveLength(2);
#+end_src

** Testing Cursor/Selection

#+begin_src javascript
// Get cursor position (firstEdge and SecondEdge are same for cursor)
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 5 });
expect(SecondEdge).toEqual({ row: 0, col: 5 });

// Check if selection exists
expect(fixture.wb.Selection.isSelection).toBe(true);

// Selection positions
const [firstEdge, SecondEdge] = fixture.wb.Selection.ordered;
expect(firstEdge).toEqual({ row: 0, col: 0 });  // Start of selection
expect(SecondEdge).toEqual({ row: 0, col: 5 });  // End of selection
#+end_src

** Skipping Tests

Use ~xit~ instead of ~it~ to skip a test:

#+begin_src javascript
runner.xit('should do something later', () => {
  // This test won't run
}, "Description");
#+end_src