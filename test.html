<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WarrenBuf Tests</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    h1 {
      color: #4EC9B0;
    }
    .test-suite {
      margin: 20px 0;
      border: 1px solid #3e3e3e;
      border-radius: 4px;
      overflow: hidden;
    }
    .test-suite-header {
      background: #2d2d30;
      padding: 12px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .test-suite-header:hover {
      background: #3e3e42;
    }
    .test-suite-body {
      padding: 16px;
    }
    .test-case {
      padding: 8px 12px;
      margin: 4px 0;
      border-radius: 3px;
      display: flex;
      align-items: center;
    }
    .test-case.pass {
      background: #1e3a1e;
      border-left: 3px solid #4CAF50;
    }
    .test-case.fail {
      background: #3a1e1e;
      border-left: 3px solid #f44336;
    }
    .test-case.skipped {
      background: #2a2a2a;
      border-left: 3px solid #757575;
      opacity: 0.6;
    }
    .test-icon {
      margin-right: 12px;
      font-weight: bold;
    }
    .test-icon.pass { color: #4CAF50; }
    .test-icon.fail { color: #f44336; }
    .test-icon.skipped { color: #757575; }
    .test-message {
      flex: 1;
    }
    .test-description {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.7;
      font-style: italic;
    }
    .test-error {
      margin-top: 8px;
      padding: 8px;
      background: #2d2d30;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #f44336;
      white-space: pre-wrap;
    }
    .summary {
      position: sticky;
      top: 0;
      background: #252526;
      padding: 16px;
      margin-bottom: 20px;
      border-radius: 4px;
      border: 1px solid #3e3e3e;
      display: flex;
      justify-content: space-between;
      z-index: 100;
    }
    .summary-item {
      text-align: center;
    }
    .summary-number {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .summary-label {
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.7;
    }
    .run-tests-btn {
      background: #0e639c;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .run-tests-btn:hover {
      background: #1177bb;
    }
    .collapsed .test-suite-body {
      display: none;
    }
    .toggle-icon {
      transition: transform 0.2s;
    }
    .collapsed .toggle-icon {
      transform: rotate(-90deg);
    }
    .editor-container {
      display: none;
    }
    .wb {
      background-color: #282C34;
      color: #B2B2B2;
      position: relative;
      outline: none;
      font-family: monospace;
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <h1>WarrenBuf Test Suite</h1>

  <div class="summary">
    <div class="summary-item">
      <div class="summary-number" id="total-tests">0</div>
      <div class="summary-label">Total</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" style="color: #4CAF50" id="passed-tests">0</div>
      <div class="summary-label">Passed</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" style="color: #f44336" id="failed-tests">0</div>
      <div class="summary-label">Failed</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" style="color: #757575" id="skipped-tests">0</div>
      <div class="summary-label">Skipped</div>
    </div>
    <button class="run-tests-btn" onclick="runAllTests()">Run All Tests</button>
  </div>

  <div id="test-results"></div>

  <!-- Hidden editor container for tests -->
  <div class="editor-container">
    <div class="wb no-select">
      <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
      <div style="display: flex">
        <div class="wb-gutter"></div>
        <div class="wb-lines" style="flex: 1; overflow: hidden;"></div>
      </div>
      <div class="wb-status" style="display: flex; justify-content: space-between;">
        <div class="wb-status-left" style="display: flex;">
          <span class="wb-linecount"></span>
        </div>
        <div class="wb-status-right" style="display: flex;">
          <span class="wb-coordinate"></span>
          <span>|</span>
          <span class="wb-indentation"></span>
        </div>
      </div>
    </div>
  </div>

  <script src="warrenbuf.js"></script>
  <script>
    // Simple test framework
    class TestRunner {
      constructor() {
        this.suites = [];
        this.currentSuite = null;
      }

      describe(name, fn) {
        const suite = { name, tests: [], beforeEach: null, afterEach: null };
        this.suites.push(suite);
        this.currentSuite = suite;
        fn();
        this.currentSuite = null;
      }

      it(name, fn, description = '') {
        if (!this.currentSuite) throw new Error('it() must be called inside describe()');
        this.currentSuite.tests.push({ name, fn, description, status: 'pending' });
      }

      xit(name, fn, description = '') {
        if (!this.currentSuite) throw new Error('xit() must be called inside describe()');
        this.currentSuite.tests.push({ name, fn, description, status: 'skipped' });
      }

      beforeEach(fn) {
        if (!this.currentSuite) throw new Error('beforeEach() must be called inside describe()');
        this.currentSuite.beforeEach = fn;
      }

      async run() {
        const results = { total: 0, passed: 0, failed: 0, skipped: 0 };

        for (const suite of this.suites) {
          const suiteResults = [];

          for (const test of suite.tests) {
            results.total++;

            if (test.status === 'skipped') {
              results.skipped++;
              suiteResults.push(test);
              continue;
            }

            try {
              if (suite.beforeEach) suite.beforeEach();
              await test.fn();

              test.status = 'pass';
              results.passed++;
            } catch (error) {
              test.status = 'fail';
              test.error = error;
              results.failed++;
            }

            suiteResults.push(test);
          }

          suite.results = suiteResults;
        }

        return results;
      }
    }

    // Assertion helpers
    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`Expected: ${JSON.stringify(expected)}\nActual: ${JSON.stringify(actual)}`);
          }
        },
        toEqual(expected) {
          if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(`Expected: ${JSON.stringify(expected)}\nActual: ${JSON.stringify(actual)}`);
          }
        },
        toHaveLength(expected) {
          if (actual.length !== expected) {
            throw new Error(`Expected length: ${expected}\nActual length: ${actual.length}\nActual value: ${JSON.stringify(actual)}`);
          }
        }
      };
    }

    // Test utilities
    function createTestEditor() {
      const container = document.querySelector('.editor-container');
      const node = container.querySelector('.wb');
      return { wb: new WarrenBuf(node), node };
    }

    function dispatchKey(node, key, modifiers = {}) {
      const event = new KeyboardEvent('keydown', {
        key,
        code: key.length === 1 ? `Key${key.toUpperCase()}` : key,
        bubbles: true,
        cancelable: true,
        metaKey: modifiers.meta || false,
        ctrlKey: modifiers.ctrl || false,
        shiftKey: modifiers.shift || false,
        altKey: modifiers.alt || false
      });
      node.dispatchEvent(event);
    }

    function type(node, text) {
      for (const char of text) {
        dispatchKey(node, char);
      }
    }

    // Test definitions
    const runner = new TestRunner();

    // Basic Typing Tests
    runner.describe('Basic Typing', () => {
      let wb, node;

      runner.beforeEach(() => {
        const editor = createTestEditor();
        wb = editor.wb;
        node = editor.node;
      });

      runner.it('should insert single character', () => {
        dispatchKey(node, 'a');
        expect(wb.Model.lines[0]).toBe('a');
      }, "Insert single character 'a'");

      runner.it('should insert multiple characters', () => {
        type(node, 'Hello');
        expect(wb.Model.lines[0]).toBe('Hello');
      }, "Insert 'Hello'");

      runner.it('should insert word with spaces', () => {
        type(node, 'Hello World');
        expect(wb.Model.lines[0]).toBe('Hello World');
      }, "Insert 'Hello World' with spaces");

      runner.it('should type sentence', () => {
        type(node, 'The quick brown fox');
        expect(wb.Model.lines[0]).toBe('The quick brown fox');
      }, "Insert sentence 'The quick brown fox'");
    });

    // Backspace Tests
    runner.describe('Backspace', () => {
      let wb, node;

      runner.beforeEach(() => {
        const editor = createTestEditor();
        wb = editor.wb;
        node = editor.node;
      });

      runner.it('should delete single character', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Backspace');
        expect(wb.Model.lines[0]).toBe('Hell');
      }, "Delete single char from 'Hello' → 'Hell'");

      runner.it('should delete multiple characters', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        expect(wb.Model.lines[0]).toBe('He');
      }, "Delete 3 chars from 'Hello' → 'He'");

      runner.it('should delete all characters', () => {
        type(node, 'Hi');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        expect(wb.Model.lines[0]).toBe('');
      }, "Delete all chars from 'Hi' → ''");
    });

    // Enter/Newline Tests
    runner.describe('Enter Key', () => {
      let wb, node;

      runner.beforeEach(() => {
        const editor = createTestEditor();
        wb = editor.wb;
        node = editor.node;
      });

      runner.it('should create new line', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Enter');
        expect(wb.Model.lines).toHaveLength(2);
        expect(wb.Model.lines[0]).toBe('Hello');
        expect(wb.Model.lines[1]).toBe('');
      }, "Create new line: 'Hello'[Enter] → 2 lines");

      runner.it('should create multiple lines', () => {
        type(node, 'Line 1');
        dispatchKey(node, 'Enter');
        type(node, 'Line 2');
        dispatchKey(node, 'Enter');
        type(node, 'Line 3');
        expect(wb.Model.lines).toHaveLength(3);
        expect(wb.Model.lines[0]).toBe('Line 1');
        expect(wb.Model.lines[1]).toBe('Line 2');
        expect(wb.Model.lines[2]).toBe('Line 3');
      }, "Create multiple lines: 'Line 1'[Enter]'Line 2'[Enter]'Line 3' → 3 lines");

      runner.it('should split line with Enter', () => {
        type(node, 'Hello');
        dispatchKey(node, 'ArrowLeft');
        dispatchKey(node, 'ArrowLeft');
        dispatchKey(node, 'Enter');
        expect(wb.Model.lines).toHaveLength(2);
        expect(wb.Model.lines[0]).toBe('Hel');
        expect(wb.Model.lines[1]).toBe('lo');
      }, "Split line: 'Hello'[ArrowLeft×2][Enter] → 'Hel' and 'lo'");
    });

    // Complex Sequences
    runner.describe('Complex Sequences', () => {
      let wb, node;

      runner.beforeEach(() => {
        const editor = createTestEditor();
        wb = editor.wb;
        node = editor.node;
      });

      runner.xit('should type, delete, and retype', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        type(node, 'y there');
        expect(wb.Model.lines[0]).toBe('Hely there');
      }, "Type, delete, retype");

      runner.xit('should create line, delete line break', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Enter');
        type(node, 'World');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        expect(wb.Model.lines).toHaveLength(1);
        expect(wb.Model.lines[0]).toBe('Hello');
      }, "Create/delete line breaks");

      runner.xit('should type multi-line then edit first line', () => {
        type(node, 'First');
        dispatchKey(node, 'Enter');
        type(node, 'Second');
        dispatchKey(node, 'ArrowUp');
        dispatchKey(node, 'ArrowRight', { meta: true });
        type(node, ' Line');
        expect(wb.Model.lines[0]).toBe('First Line');
        expect(wb.Model.lines[1]).toBe('Second');
      }, "Multi-line editing");

      runner.xit('should delete across line boundary', () => {
        type(node, 'Hello');
        dispatchKey(node, 'Enter');
        type(node, 'World');
        dispatchKey(node, 'ArrowUp');
        dispatchKey(node, 'ArrowRight', { meta: true });
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        dispatchKey(node, 'Backspace');
        expect(wb.Model.lines).toHaveLength(1);
        expect(wb.Model.lines[0]).toBe('World');
      }, "Delete across boundaries");

      runner.xit('should create paragraph and edit middle', () => {
        type(node, 'Line 1');
        dispatchKey(node, 'Enter');
        type(node, 'Line 2');
        dispatchKey(node, 'Enter');
        type(node, 'Line 3');
        dispatchKey(node, 'ArrowUp');
        dispatchKey(node, 'ArrowRight', { meta: true });
        type(node, ' edited');
        expect(wb.Model.lines).toHaveLength(3);
        expect(wb.Model.lines[0]).toBe('Line 1');
        expect(wb.Model.lines[1]).toBe('Line 2 edited');
        expect(wb.Model.lines[2]).toBe('Line 3');
      }, "Edit middle of paragraph");
    });

    // Render results
    function renderResults(results) {
      const resultsContainer = document.getElementById('test-results');
      resultsContainer.innerHTML = '';

      runner.suites.forEach(suite => {
        const suiteDiv = document.createElement('div');
        suiteDiv.className = 'test-suite';

        const suiteHeader = document.createElement('div');
        suiteHeader.className = 'test-suite-header';
        const passedInSuite = suite.results.filter(t => t.status === 'pass').length;
        const failedInSuite = suite.results.filter(t => t.status === 'fail').length;
        suiteHeader.innerHTML = `
          <div>
            <span>${suite.name}</span>
            <span style="margin-left: 12px; opacity: 0.7; font-size: 12px;">
              ${passedInSuite} passed, ${failedInSuite} failed
            </span>
          </div>
          <span class="toggle-icon">▼</span>
        `;
        suiteHeader.onclick = () => suiteDiv.classList.toggle('collapsed');

        const suiteBody = document.createElement('div');
        suiteBody.className = 'test-suite-body';

        suite.results.forEach(test => {
          const testDiv = document.createElement('div');
          testDiv.className = `test-case ${test.status}`;

          const icon = test.status === 'pass' ? '✓' : test.status === 'fail' ? '✗' : '○';
          testDiv.innerHTML = `
            <span class="test-icon ${test.status}">${icon}</span>
            <div class="test-message">
              ${test.name}
              ${test.description ? `<div class="test-description">${test.description}</div>` : ''}
              ${test.error ? `<div class="test-error">${test.error.message}</div>` : ''}
            </div>
          `;

          suiteBody.appendChild(testDiv);
        });

        suiteDiv.appendChild(suiteHeader);
        suiteDiv.appendChild(suiteBody);
        resultsContainer.appendChild(suiteDiv);
      });

      document.getElementById('total-tests').textContent = results.total;
      document.getElementById('passed-tests').textContent = results.passed;
      document.getElementById('failed-tests').textContent = results.failed;
      document.getElementById('skipped-tests').textContent = results.skipped;
    }

    async function runAllTests() {
      const results = await runner.run();
      renderResults(results);
    }

    window.addEventListener('DOMContentLoaded', runAllTests);
  </script>
</body>
</html>
