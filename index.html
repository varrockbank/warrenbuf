<html>
<head>
<script src="warrenbuf.js"></script>
<style>
  /************* "Atomic CSS" classes for Boxes *************/
  .💪 { display: flex }                                 /* Flex like muscles.   */
  .🥷 { overflow: hidden }
  .🪜 { flex-flow: column }
  .🌳 { flex: 1 }                                       /* Grow like a tree.    */
  .🦠 { justify-content: space-between }                /* Stay spread apart.   */

  .hidden {
    display: none;
  }

  body {
      background-color: #494460;
      color: white;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      font-size: 20px;
      font-family: "Helvetica", sans-serif;
  }
  blockquote {
      margin: 15px;
  }
  /*** Classes for WarrenBuf ***/
  .wb {
      background-color: #282C34;
      color: #B2B2B2;
      position: relative;
      outline: none;
      font-family: monospace;
      border: 1px solid black;
  }
  .no-select {
      user-select: none;       /* Standard */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none;    /* Firefox */
      -ms-user-select: none;     /* IE/Edge (old) */
  }
  /* Bridge must be selectable but invisible & offscreen */
  .wb-clipboard-bridge {
      position: fixed;      /* out of normal flow so it won't jump layout */
      left: 0;
      top: 1px;
      width: 0;
      height: 1px;
      opacity: 0;
      pointer-events: none; /* avoid clicks */
  }

  .wb .wb-lines>pre::before {
      content: "\200B";
  }
  .wb .wb-lines pre {
      margin: 0;
      overflow: hidden;
  }
  .wb .wb-selection {
      left: 0ch;
      top: 0ch;
      background-color: #EDAD10;
      position: absolute;
      mix-blend-mode: difference;        /* inverts underlying pixels */
  }
  .wb .wb-status span {
      padding-right: 4px;
  }
  .wb .wb-lines pre .highlight-function {
      color: orange;
  }
  .wb .wb-lines pre .highlight-function-name {
      color: cadetblue ;
  }
  .wb .wb-lines pre .highlight-string {
      color: green;
  }

  #hackernews.wb {
      background-color: #F6F6EF;
      color: black;
  }
  #hackernews.wb .wb-selection {
      background-color: #DCDCDA;
  }

  #playground.wb {
    background-color: #201430;
    color: #E1D6F8;
  }
  #playground.wb .wb-selection {
    background-color: #F9AD40;
  }

  #starwars.wb {
    background-color: #000000;
    color: #FFD700;
  }
  #starwars.wb .wb-selection {
    background-color: #333333;
  }

  #play-pause-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 10px 24px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  #play-pause-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
  }
  #play-pause-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  #matrix.wb {
    background-color: #000000;
    color: #00ff41;
  }
  #matrix.wb .wb-selection {
    background-color: #003300;
  }

  a {
    color: #00ff41;
    margin-right: 10px;
    margin-left: 10px;
    text-decoration: none;
  }
  a:visited {
    text-decoration: none;
  }
  a:hover {
    color: white;
    text-decoration: underline;
  }

  details {
    background-color: #3a3550;
    border-radius: 8px;
    padding: 15px 20px;
    margin: 15px;
    border: 1px solid #555;
  }

  summary {
    cursor: pointer;
    font-weight: 600;
    font-size: 18px;
    padding: 5px 0;
    list-style: none;
  }

  summary:hover {
    color: white;
  }

  summary::marker {
    display: none;
  }

  summary::before {
    display: inline-block;
    transition: transform 0.2s;
  }

  details > div {
    margin-top: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
  }

  details button {
    background-color: #5a5570;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
  }

  details button:hover {
    background-color: #6a6580;
  }

  details input {
    background-color: #2a2540;
    color: white;
    border: 1px solid #555;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 14px;
    width: 80px;
  }

  details label {
    font-size: 14px;
    color: #ccc;
  }

  fieldset {
    margin: 15px;
    border: 1px solid #555;
    border-radius: 5px;
    padding: 10px;
    overflow: visible;
  }

  input[type="file"]::file-selector-button {
    background-color: #5a5570;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    margin-right: 10px;
  }

  input[type="file"]::file-selector-button:hover {
    background-color: #6a6580;
  }

  input[type="file"] {
    color: #ccc;
    font-size: 14px;
    border: none;
    background: none;
    max-width: 100%;
  }
</style>
</head>

<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1 style="margin: 0;">WarrenBuf Gallery</h1>
    <div style="margin-right: 5px">
      <a href="test">Tests</a> |
      <a href="https://github.com/varrockbank/warrenbuf">Github</a>
    </div>
  </div>
  A performant text buffer for the web with editor functionality.
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="playground">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
      <div class="💪">
          <div class="wb-gutter"></div>
          <div class="wb-lines 🌳 🥷"></div>
      </div>
      <div class="💪 wb-status 🦠">
          <div class="wb-status-left 💪">
              <span class="wb-linecount"></span>
          </div>
          <div class="wb-status-right 💪">
              <span class="wb-coordinate"></span>
              <span>|</span>
              <span class="wb-indentation"></span>
          </div>
      </div>
  </blockquote>
  <details>
    <summary>Diagnostics tools for loading large files</summary>
    <fieldset>
      <legend>Viewport:</legend>
      <label for="viewport-start">Start:</label>
      <input id="viewport-start" value="0"></input>
      <label for="viewport-size">Window size:</label>
      <input id="viewport-size" value="10"></input>
      <button id="viewport-update">Set</button>
      <!-- <button id="viewport-scroll-up-1">Scroll Up</button>
      <button id="viewport-scroll-down-1">Scroll Down</button> -->
    </fieldset>
    <fieldset>
      <legend>File Loader:</legend>
      <div>
        <label for="file-input"><span id="fileSize"></span></label>
        <input id="file-input" type="file" name="myFiles" style="width: 100%; box-sizing: border-box;">
        
        <div id="file-loader-buttons" class="hidden" style="margin-top: 10px;">
          <label for="append-at-line">At line: </label><input id="append-at-line" value="1" ></input>
          <div style="margin: 10px">
            <button id="load-file">Load File</button>
           <button id="append-file">Append File (workaround for lack of chunk-loader)</button><br />
          </div>
        </div>
      </div>
    </fieldset>
  </details>

  <h2>With iOS plugin</h2>
  The following editor has the iOS plugin enabled on it.
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="notes">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>HackerNews frontpage</h2>
  Example of editor with internet-sourced data.
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="hackernews">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>ASCII Movie</h2>

  <p>Reversing engineering the 2MB file of: https://www.asciimation.co.nz/starwars</p>
  
  <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">
    <button id="play-pause-btn">Play</button>
    <div style="display: flex; align-items: center; gap: 8px;">
      <label for="speed-slider">Speed:</label>
      <input type="range" id="speed-slider" min="1" max="300" value="120" style="width: 120px;" />
      <span id="speed-value">120ms</span>
    </div>
  </div>
  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
    Frame: <span id="frame-counter" style="min-width: 90px;">0 / 0</span>
    <input type="range" id="frame-slider" min="0" max="0" value="0" style="flex: 1;" />
  </div>
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="starwars">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>Matrix Effect</h2>
  <p>Digital rain animation inspired by The Matrix</p>
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="matrix">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <script type="module">
    import { Parser, Language, Query } from "https://cdn.jsdelivr.net/npm/web-tree-sitter@0.25.10/tree-sitter.js";

    await Parser.init(); // loads tree-sitter.wasm from the same CDN path
    const treesitterParser = new Parser();
    const javascriptParser = await Language.load(
      "https://cdn.jsdelivr.net/npm/tree-sitter-wasms@0.1.12/out/tree-sitter-javascript.wasm"
    );
    treesitterParser.setLanguage(javascriptParser);
    const highlightQuery = `
      (function_declaration name: (identifier) @function)
      (string) @string
    `;
    const query = new Query(javascriptParser, highlightQuery);
    
    window.treesitterInstance = {
       query,
       parser: treesitterParser 
    };

</script>
<script>
  window.addEventListener("DOMContentLoaded", () => {

    const mainElement = document.getElementById("playground");
    const primary = new WarrenBuf(mainElement, {
      colorPrimary: "#87FF5F",
      colorSecondary: "#38274D",
    });
    mainElement.focus();
    window.primary = primary;

    const notesElement = document.getElementById('notes');
    const notes = new WarrenBuf(notesElement);

    const hackerNewsElement = document.getElementById('hackernews');
    const hackernews = new WarrenBuf(hackerNewsElement, {
      colorPrimary: "black",
      colorSecondary: "#FF6602",
    });

    const starWarsElement = document.getElementById('starwars');
    const starwars = new WarrenBuf(starWarsElement, {
      colorPrimary: "#FFD700",
      colorSecondary: "#000000",
      initialViewportSize: 13
    });

    const matrixElement = document.getElementById('matrix');
    const matrix = new WarrenBuf(matrixElement, {
      colorPrimary: "#00ff41",
      colorSecondary: "#000000",
      initialViewportSize: 20
    });

    // Diagnostics -- Bind UI controls to move viewport
    document.getElementById('viewport-update').addEventListener('click', () => {
      const viewportStart = parseInt(document.getElementById('viewport-start').value);
      const viewportSize = parseInt(document.getElementById('viewport-size').value);
      primary.Viewport.set(viewportStart, viewportSize);
    });
    // document.getElementById('viewport-scroll-up-1').addEventListener('click', () => {
    //   primary.Viewport.scroll(-1);
    // });
    // document.getElementById('viewport-scroll-down-1').addEventListener('click', () => {
    //   primary.Viewport.scroll(1);
    // });
    document.getElementById("file-input").addEventListener("change", () => {
      const file = document.getElementById("file-input").files[0];
      const nBytes = file.size;
      const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
      let sOutput = "";
      for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
        sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
      }
      document.getElementById("fileSize").innerHTML = "File size: " + (sOutput || (nBytes + " bytes"));
      document.getElementById("file-loader-buttons").classList.remove('hidden');
    }, false);
    document.getElementById('load-file').addEventListener('click', () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
      } else {
        f.text().then(text => primary.Model.text = text);
      }
    });
    document.getElementById('append-file').addEventListener('click', () => {
      const lineNumber = parseInt(document.getElementById('append-at-line').value);
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
      } else {
        f.text().then(text => {
          const s = text.split("\n");
          const t0 = performance.now();
          primary.Model.splice(lineNumber, s);
          const t1 = performance.now();
          console.log(`Took ${parseFloat(t1 - t0).toFixed(2)} millis to splice ${s.length.toLocaleString()} elements at ${index.toLocaleString()} w/ ${primary.Model.lc.toLocaleString()} lines.`);
        });
      }
    });

    fetch("docs/instructions.txt")
      .then(response => response.text())
      .then(source => primary.Model.text = source)
      .catch(err => console.error("Error reading instructions.txt:", err));

    fetch("docs/devlog.txt")
      .then(response => response.text())
      .then(source => notes.Model.text = source)
      .catch(err => console.error("Error reading devlog.txt:", err));

    // Fetch Hacker News as plaintext
    async function fetchHackerNewsText() {
      const response = await fetch('https://hacker-news.firebaseio.com/v0/topstories.json');
      const storyIds = await response.json();

      // Get top 30 stories
      const stories = await Promise.all(
        storyIds.slice(0, 30).map(async (id) => {
          const storyRes = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`);
          return storyRes.json();
        })
      );

      // Format as plaintext
      const plaintext = stories
        .map((story, i) => {
          const title = story.title || 'No title';
          const url = story.url || `https://news.ycombinator.com/item?id=${story.id}`;
          const points = story.score || 0;
          const comments = story.descendants || 0;
          return `${i + 1}. ${title}\n   ${url}\n   ${points} points | ${comments} comments\n`;
        })
        .join('\n');

      return plaintext;
    }

    fetchHackerNewsText()
      .then(text => hackernews.Model.text = text)
      .catch(err => console.error("Error fetching Hacker News:", err));

    // Star Wars ASCII Movie Player - Load full movie from sw.txt
    let movieData = null;

    async function loadStarWarsMovie() {
      try {
        const response = await fetch('sw.txt');
        // TODO: We aren't escape the ' character correctly. so \' shows literally .
        movieData = await response.text();
        // Parse frames from movie data
        const rawFrames = movieData.split('\\n'); // Split on literal \n string
        const LINES_PER_FRAME = 14;
        frames = [];

        for (let i = 0; i < rawFrames.length; i += LINES_PER_FRAME) {
          const metadata = rawFrames[i]
          const numFrames = parseInt(metadata);
          const frame = rawFrames.slice(i+1, i + LINES_PER_FRAME).join('\n');
          if(frame.trim()) {
            for(let i = 0; i < numFrames; i++) {
              frames.push(frame);
            }
          }
        }

        document.getElementById('frame-slider').max = frames.length - 1;
        currentFrame = 750;
        showFrame(750);
      } catch (err) {
        console.error("Error loading Star Wars movie:", err);
        starwars.Model.text = "Error loading movie. Check that sw.txt is in the same directory.";
      }
    }

    const LINES_PER_FRAME = 14;
    let frames = [];
    let currentFrame = 0;
    let isPlaying = false;
    let frameInterval = null;
    let frameDelay = 120;

    function showFrame(frameIndex) {
      if (frames.length > 0) {
        starwars.Model.text = frames[frameIndex % frames.length];
        document.getElementById('frame-counter').textContent = `${frameIndex + 1} / ${frames.length}`;
        document.getElementById('frame-slider').value = frameIndex;
      }
    }

    function playMovie() {
      if (isPlaying) return;
      isPlaying = true;
      document.getElementById('play-pause-btn').textContent = 'Pause';

      frameInterval = setInterval(() => {
        showFrame(currentFrame);
        currentFrame = (currentFrame + 1) % frames.length;
      }, frameDelay);
    }

    function pauseMovie() {
      isPlaying = false;
      document.getElementById('play-pause-btn').textContent = 'Play';
      if (frameInterval) {
        clearInterval(frameInterval);
        frameInterval = null;
      }
    }


    // Controls
    document.getElementById('play-pause-btn').addEventListener('click', () => {
      if (isPlaying) {
        pauseMovie();
      } else {
        playMovie();
      }
    });

    document.getElementById('speed-slider').addEventListener('input', (e) => {
      frameDelay = parseInt(e.target.value);
      document.getElementById('speed-value').textContent = frameDelay + 'ms';
      if (isPlaying) {
        pauseMovie();
        playMovie();
      }
    });

    document.getElementById('frame-slider').addEventListener('input', (e) => {
      currentFrame = parseInt(e.target.value);
      showFrame(currentFrame);
    });

    // Load and show movie
    loadStarWarsMovie();

    // Autoplay when scrolled into view
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !isPlaying && frames.length > 0) {
          playMovie();
          observer.unobserve(starWarsElement); // Only autoplay once
        }
      });
    }, { threshold: 0.5 });

    observer.observe(starWarsElement);

    // Matrix Effect Animation
    const MATRIX_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%^&*()_+-=[]{}|;:,.<>?/~`';
    const MATRIX_COLS = 80;
    const MATRIX_ROWS = 20;
    let matrixColumns = [];

    // Initialize columns with random starting positions
    for (let i = 0; i < MATRIX_COLS; i++) {
      matrixColumns.push({
        y: Math.floor(Math.random() * MATRIX_ROWS),
        speed: Math.random() * 0.5 + 0.3, // Random speed between 0.3 and 0.8
        chars: Array(MATRIX_ROWS).fill(' ')
      });
    }

    function updateMatrix() {
      const lines = [];

      // Update each column
      matrixColumns.forEach((col, colIndex) => {
        // Move column down
        col.y += col.speed;

        // Reset to top if reached bottom
        if (col.y > MATRIX_ROWS + 10) {
          col.y = -Math.random() * 10;
          col.speed = Math.random() * 0.5 + 0.3;
        }

        // Add new character at head position
        const headRow = Math.floor(col.y);
        if (headRow >= 0 && headRow < MATRIX_ROWS) {
          col.chars[headRow] = MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
        }

        // Fade out trailing characters
        for (let row = 0; row < MATRIX_ROWS; row++) {
          if (row < headRow - 15) {
            col.chars[row] = ' ';
          } else if (Math.random() < 0.05) {
            // Randomly change some characters for glitch effect
            col.chars[row] = MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
          }
        }
      });

      // Build the display grid
      for (let row = 0; row < MATRIX_ROWS; row++) {
        let line = '';
        for (let col = 0; col < MATRIX_COLS; col++) {
          line += matrixColumns[col].chars[row];
        }
        lines.push(line);
      }

      matrix.Model.text = lines.join('\n');
    }

    // Start Matrix animation
    setInterval(updateMatrix, 50); // Update every 50ms

    if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
      const notesEditingArea = notesElement.querySelector('.wb-lines');
   
      // Use contenteditable so tapping opens the keyboard
      editor.setAttribute('contenteditable', 'true');
      editor.setAttribute('role', 'textbox');
      editor.setAttribute('aria-multiline', 'true');
      editor.setAttribute('spellcheck', 'false');
      editor.setAttribute('autocapitalize', 'off');
      editor.setAttribute('autocorrect', 'off');
      editor.setAttribute('inputmode', 'text');

      // ---------- iOS adapter: hidden textarea "input sink" ----------
      const sink = document.createElement('textarea');
      sink.setAttribute('autocapitalize', 'off');
      sink.setAttribute('autocorrect', 'off');
      sink.setAttribute('spellcheck', 'false');
      Object.assign(sink.style, {
        position: 'fixed',
        opacity: 0,
        left: '0',
        top: '0',
        height: '1px',
        width: '1px',
      });
      // Fake out a deletion event so iOS fires deleteContentBackward input time
      // Otherwise the keyboard handler with a synthetic Backspace event is never claled.
      const L = '\u200B';           // left sentinel (zero-width space)
      const R = '\u200B';           // right sentinel (optional, helps if you add ForwardDelete later)
      sink.value = L + R ;
      document.body.appendChild(sink);
      function resetSink() {
        sink.value = L + R;                 // always 2 chars
        sink.selectionStart = sink.selectionEnd = 1; // caret between L and R
      }

      // Measure 1ch using the div's font (reliable across browsers)
      function measureChWidth() {
        // Fast path using CSS 1ch
        const probe = document.createElement('span');
        probe.textContent = '0';
        // Match the target div’s font & letter spacing
        const cs = getComputedStyle(notesEditingArea);
        probe.style.font = cs.font;
        probe.style.letterSpacing = cs.letterSpacing;
        probe.style.visibility = 'hidden';
        probe.style.position = 'absolute';
        probe.style.whiteSpace = 'pre';
        document.body.appendChild(probe);
        const w = probe.getBoundingClientRect().width;
        document.body.removeChild(probe);
        return w;
      }
      let ch = measureChWidth();
      // Recompute on font changes / resize (optional but nice)
      new ResizeObserver(() => { ch = measureChWidth(); }).observe(notesEditingArea);

      function getPoint(evt) {
        const rect = notesEditingArea.getBoundingClientRect();
        const touch = evt.changedTouches?.[0] ?? evt.touches?.[0];
        const clientX = touch ? touch.clientX : evt.clientX;
        const clientY = touch ? touch.clientY : evt.clientY;
        // position inside content box, including scroll offset
        // (rect gives viewport coords; add scroll to get content coords)
        const x = (clientX - rect.left) + notesEditingArea.scrollLeft;
        const y = (clientY - rect.top)  + notesEditingArea.scrollTop;
        // subtract padding so (0,0) = top-left of text content, not the padding
        const cs = getComputedStyle(notesEditingArea);
        const padL = parseFloat(cs.paddingLeft)  || 0;
        const padT = parseFloat(cs.paddingTop)   || 0;
        return { x: x - padL, y: y - padT };
      }

      function setCursor(evt) {
        const { x, y } = getPoint(evt);
        const row = Math.max(0, Math.floor(y / 24));
        const col = Math.max(0, Math.floor(x / ch));
        notes.Selection.iosSetCursorAndRender({ row, col });
      }

      // Map beforeinput → synthetic keydown(s)
      sink.addEventListener('beforeinput', (e) => {
        // We consume the DOM change; we’ll notify the editor via keydown.
        e.preventDefault();

        if(e.inputType === 'insertText') {
          for (const ch of e.data || '') synthKeydown(ch);
        } else if (e.inputType === 'deleteContentBackward') {
          synthKeydown('Backspace');
        } else if (e.inputType === 'insertLineBreak') {
          synthKeydown('Enter');
        }
        resetSink(); // <- ALWAYS restore L•R with caret in the middle
      });
      // IME/dictation: commit composed text as keydowns
      sink.addEventListener('compositionend', (e) => {
        if (e.data) {
          for (const ch of e.data) synthKeydown(ch);
        }
      });
      // Helper: dispatch a synthetic keydown into your editor
      function synthKeydown(key) {
        // Use only what your handler needs; e.key is the important bit.
        const ev = new KeyboardEvent('keydown', {
          key,
          bubbles: true,
          cancelable: true,
          // Best-effort code; fine if it's not perfect for non-letters.
          code: key.length === 1 ? ('Key' + key.toUpperCase()) : key
        });
        // Some code checks isTrusted; this won’t be trusted, so avoid that check.
        editor.dispatchEvent(ev);
      }

      // Focus on tap (otherwise iOS may not show keyboard)
      // Focus the sink on tap so iOS shows the keyboard.
      editor.addEventListener('pointerdown', e => {
        sink.focus({preventScroll: true});
        setCursor(e);
      });
    }
  });
</script>
</body>
</html>
