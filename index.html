<html>
<head>
<meta charset="UTF-8">
<script src="warrenbuf.js"></script>
<style>
  /************* "Atomic CSS" classes for Boxes *************/
  .ðŸ’ª { display: flex }                                 /* Flex like muscles.   */
  .ðŸ¥· { overflow: hidden }
  .ðŸªœ { flex-flow: column }
  .ðŸŒ³ { flex: 1 }                                       /* Grow like a tree.    */
  .ðŸ¦  { justify-content: space-between }                /* Stay spread apart.   */

  .hidden {
    display: none;
  }

  body {
      background-color: #494460;
      color: white;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      font-size: 20px;
      font-family: "Helvetica", sans-serif;
  }
  blockquote {
      margin: 15px;
  }
  /*** Classes for WarrenBuf ***/
  .wb {
      background-color: #282C34;
      color: #B2B2B2;
      position: relative;
      outline: none;
      font-family: 'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace;
      border: 1px solid black;
  }
  .no-select {
      user-select: none;       /* Standard */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none;    /* Firefox */
      -ms-user-select: none;     /* IE/Edge (old) */
  }
  /* Bridge must be selectable but invisible & offscreen */
  .wb-clipboard-bridge {
      position: fixed;      /* out of normal flow so it won't jump layout */
      left: 0;
      top: 1px;
      width: 0;
      height: 1px;
      opacity: 0;
      pointer-events: none; /* avoid clicks */
  }

  .wb .wb-lines>pre::before {
      content: "\200B";
  }
  .wb .wb-lines pre {
      margin: 0;
      overflow: hidden;
  }
  .wb .wb-selection {
      left: 0ch;
      top: 0ch;
      background-color: #EDAD10;
      position: absolute;
      mix-blend-mode: difference;        /* inverts underlying pixels */
  }
  .wb .wb-status span {
      padding-right: 4px;
  }
  .wb .wb-lines pre .highlight-function {
      color: orange;
  }
  .wb .wb-lines pre .highlight-function-name {
      color: cadetblue ;
  }
  .wb .wb-lines pre .highlight-string {
      color: green;
  }

  #hackernews.wb {
      background-color: #F6F6EF;
      color: black;
  }
  #hackernews.wb .wb-selection {
      background-color: #DCDCDA;
  }

  #playground.wb {
    background-color: #201430;
    color: #E1D6F8;
  }
  #playground.wb .wb-selection {
    background-color: #F9AD40;
  }

  #starwars.wb {
    background-color: #000000;
    color: #FFD700;
  }
  #starwars.wb .wb-selection {
    background-color: #333333;
  }

  #play-pause-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 10px 24px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  #play-pause-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
  }
  #play-pause-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  #matrix.wb {
    background-color: #000000;
    color: #00ff41;
  }
  #matrix.wb .wb-selection {
    background-color: #003300;
  }

  #conway.wb {
    background-color: white;
    color: black;
  }
  #conway.wb .wb-selection {
    background-color: #DCDCDA;
  }

  a {
    color: #00ff41;
    margin-right: 10px;
    margin-left: 10px;
    text-decoration: none;
  }
  a:visited {
    text-decoration: none;
  }
  a:hover {
    color: white;
    text-decoration: underline;
  }

  details {
    background-color: #3a3550;
    border-radius: 8px;
    padding: 15px 20px;
    margin: 15px;
    border: 1px solid #555;
  }

  summary {
    cursor: pointer;
    font-weight: 600;
    font-size: 18px;
    padding: 5px 0;
    list-style: none;
  }

  summary:hover {
    color: white;
  }

  summary::marker {
    display: none;
  }

  summary::before {
    display: inline-block;
    transition: transform 0.2s;
  }

  details > div {
    margin-top: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
  }

  details button {
    background-color: #5a5570;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
  }

  details button:hover {
    background-color: #6a6580;
  }

  details input {
    background-color: #2a2540;
    color: white;
    border: 1px solid #555;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 14px;
    width: 80px;
  }

  details label {
    font-size: 14px;
    color: #ccc;
  }

  fieldset {
    margin: 15px;
    border: 1px solid #555;
    border-radius: 5px;
    padding: 10px;
    overflow: visible;
  }

  input[type="file"]::file-selector-button {
    background-color: #5a5570;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    margin-right: 10px;
  }

  input[type="file"]::file-selector-button:hover {
    background-color: #6a6580;
  }

  input[type="file"] {
    color: #ccc;
    font-size: 14px;
    border: none;
    background: none;
    max-width: 100%;
  }
  
  #file-loader-options {
    display: flex;
    flex-direction: column;
  }

  #file-loader-options button {
    margin: 10px;

  }

  .read-only-indicator {
    background-color: #ff6b35;
    color: white;
    padding: 8px 15px;
    text-align: center;
    font-weight: 600;
    border-radius: 15px 15px 0 0;
    margin: 15px 15px 0px 15px;
  }
</style>
</head>

<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1 style="margin: 0;">WarrenBuf Gallery</h1>
    <div style="margin-right: 5px">
      <a href="test">Unit tests</a> |
      <a href="perf">Perf Characterization</a> |
      <a href="https://github.com/varrockbank/warrenbuf">Github</a>
    </div>
  </div>
  <div style="margin-bottom: 15px">
    A performant text buffer for the web with editor functionality.
  </div>
  <div id="read-only-indicator" class="read-only-indicator hidden">
    ðŸ“– Read-Only Mode (Chunked+Compressed) - Navigation only, editing disabled
  </div>
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="playground" style="margin-top: 0;">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
      <div class="ðŸ’ª">
          <div class="wb-gutter"></div>
          <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
      </div>
      <div class="ðŸ’ª wb-status ðŸ¦ ">
          <div class="wb-status-left ðŸ’ª">
              <span class="wb-linecount"></span>
          </div>
          <div class="wb-status-right ðŸ’ª">
              <span class="wb-coordinate"></span>
              <span>|</span>
              <span class="wb-indentation"></span>
          </div>
      </div>
  </blockquote>
  <details>
    <summary>Large File Diagnostics</summary>
    <fieldset>
      <legend>Viewport:</legend>
      <label for="viewport-start">Start:</label>
      <input id="viewport-start" value="1"></input>
      <label for="viewport-size">Window size:</label>
      <input id="viewport-size" value="10"></input>
      <button id="viewport-update">Set</button>
    </fieldset>
    <fieldset>
      <legend>File Loader:</legend>
      <div>
        <label for="file-input"><span id="fileSize"></span></label>
        <input id="file-input" type="file" name="myFiles" style="width: 100%; box-sizing: border-box;">
        
        <div id="file-loader-buttons" class="hidden" style="margin-top: 10px;">
          <label for="append-at-line">At line: </label><input id="append-at-line" value="1" ></input>
          <div style="margin: 10px" id="file-loader-options">
            <button id="load-file-naive">Naive file loader (&lt;10 million line of code files. Fast)</button>
            <button id="load-file-chunked">File.slice byte chunk loader (&lt;70 million CLOC. Faster)</button>
            <button id="load-file-filereader">FileReader chunk loader (&lt;70 million CLOC. Faster)</button>
            <button id="load-file-stream">ReadableStream (&lt;70 million CLOC. Faster)</button>
            <button id="load-file-stream-materialized">ReadableStream w/ materialized strings (&lt;75M CLOC. Slow)</button>
            <button id="load-file-stream-materialized-gc">ReadableStream w/ materialized strings + force GC (&lt;70-90M CLOC. Non-deterministic; depends on mood of GC. Slower)</button>
            <button id="load-file-chunked-compressed">Ultra-high-capacity Mode (1 billion+ CLOC. Slowest. Read-only, for now.)</button>
          </div>
          <h3>Logviewer for ultra-high-capacity-mode:</h3>
          <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="file-loader-logs" style="margin-top: 0;">
          <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
          <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
            <div class="ðŸ’ª">
                <div class="wb-gutter"></div>
                <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
            </div>
            <div class="ðŸ’ª wb-status ðŸ¦ ">
                <div class="wb-status-left ðŸ’ª">
                    <span class="wb-linecount"></span>
                </div>
                <div class="wb-status-right ðŸ’ª">
                    <span class="wb-coordinate"></span>
                    <span>|</span>
                    <span class="wb-indentation"></span>
                </div>
            </div>
          </blockquote>
        </div>
      </div>
    </fieldset>
  </details>

  <h2>With iOS plugin</h2>
  The following editor has the iOS plugin enabled on it.
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="notes">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="ðŸ’ª">
      <div class="wb-gutter"></div>
      <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
    </div>
    <div class="ðŸ’ª wb-status ðŸ¦ ">
      <div class="wb-status-left ðŸ’ª">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right ðŸ’ª">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>HackerNews frontpage</h2>
  Example of editor with internet-sourced data.
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="hackernews">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="ðŸ’ª">
      <div class="wb-gutter"></div>
      <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
    </div>
    <div class="ðŸ’ª wb-status ðŸ¦ ">
      <div class="wb-status-left ðŸ’ª">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right ðŸ’ª">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>ASCII Movie</h2>

  <p>Reversing engineering the 2MB file of: https://www.asciimation.co.nz/starwars</p>
  
  <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">
    <button id="play-pause-btn">Play</button>
    <div style="display: flex; align-items: center; gap: 8px;">
      <label for="speed-slider">Speed:</label>
      <input type="range" id="speed-slider" min="1" max="300" value="120" style="width: 120px;" />
      <span id="speed-value">120ms</span>
    </div>
  </div>
  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
    Frame: <span id="frame-counter" style="min-width: 90px;">0 / 0</span>
    <input type="range" id="frame-slider" min="0" max="0" value="0" style="flex: 1;" />
  </div>
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="starwars">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="ðŸ’ª">
      <div class="wb-gutter"></div>
      <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
    </div>
    <div class="ðŸ’ª wb-status ðŸ¦ ">
      <div class="wb-status-left ðŸ’ª">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right ðŸ’ª">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>Matrix Effect</h2>
  <p>Digital rain animation inspired by The Matrix</p>
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="matrix">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="ðŸ’ª">
      <div class="wb-gutter"></div>
      <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
    </div>
    <div class="ðŸ’ª wb-status ðŸ¦ ">
      <div class="wb-status-left ðŸ’ª">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right ðŸ’ª">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <h2>Conway's Game of Life</h2>
  <p>Cellular automaton simulation - watch patterns evolve and interact</p>
  <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">
    <button id="conway-play-pause-btn">Play</button>
    <button id="conway-reset-btn">Reset</button>
    <div style="display: flex; align-items: center; gap: 8px;">
      <label for="conway-speed-slider">Speed:</label>
      <input type="range" id="conway-speed-slider" min="50" max="1000" value="200" style="width: 120px;" />
      <span id="conway-speed-value">200ms</span>
    </div>
  </div>
  <blockquote cite="" class="ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="conway">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="ðŸ’ª">
      <div class="wb-gutter"></div>
      <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
    </div>
    <div class="ðŸ’ª wb-status ðŸ¦ ">
      <div class="wb-status-left ðŸ’ª">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right ðŸ’ª">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <script type="module">
    import { Parser, Language, Query } from "https://cdn.jsdelivr.net/npm/web-tree-sitter@0.25.10/tree-sitter.js";

    await Parser.init(); // loads tree-sitter.wasm from the same CDN path
    const treesitterParser = new Parser();
    const javascriptParser = await Language.load(
      "https://cdn.jsdelivr.net/npm/tree-sitter-wasms@0.1.12/out/tree-sitter-javascript.wasm"
    );
    treesitterParser.setLanguage(javascriptParser);
    const highlightQuery = `
      (function_declaration name: (identifier) @function)
      (string) @string
    `;
    const query = new Query(javascriptParser, highlightQuery);
    
    window.treesitterInstance = {
       query,
       parser: treesitterParser 
    };

</script>
<script>
  window.addEventListener("DOMContentLoaded", () => {

    const fileLoaderLoggerElement = document.getElementById('file-loader-logs');
    const fileLoaderLogger = new WarrenBuf(fileLoaderLoggerElement, {
      colorPrimary: "#87FF5F",
      colorSecondary: "#38274D",
      initialViewportSize: 5,
      showGutter: false
    });

    function compressedFileLoaderLogger(s) {
      console.log(s);
      fileLoaderLogger.appendLineAtEnd(s);
    };
    const mainElement = document.getElementById("playground");
    const primary = new WarrenBuf(mainElement, {
      colorPrimary: "#87FF5F",
      colorSecondary: "#38274D",
      logger: compressedFileLoaderLogger
    });
    mainElement.focus();
    window.primary = primary;

    const notesElement = document.getElementById('notes');
    const notes = new WarrenBuf(notesElement);

    const hackerNewsElement = document.getElementById('hackernews');
    const hackernews = new WarrenBuf(hackerNewsElement, {
      colorPrimary: "black",
      colorSecondary: "#FF6602",
      showStatusLine: false,
    });

    const starWarsElement = document.getElementById('starwars');
    const starwars = new WarrenBuf(starWarsElement, {
      colorPrimary: "#FFD700",
      colorSecondary: "#000000",
      initialViewportSize: 13,
      showGutter: false,
    });

    const matrixElement = document.getElementById('matrix');
    const matrix = new WarrenBuf(matrixElement, {
      colorPrimary: "#00ff41",
      colorSecondary: "#000000",
      initialViewportSize: 20,
      showStatusLine: false,
    });

    const conwayElement = document.getElementById('conway');
    const conway = new WarrenBuf(conwayElement, {
      colorPrimary: "black",
      colorSecondary: "white",
      initialViewportSize: 30,
      showStatusLine: false,
      showGutter: false,
    });

    // Diagnostics -- Bind UI controls to move viewport
    document.getElementById('viewport-update').addEventListener('click', () => {
      const viewportStart = parseInt(document.getElementById('viewport-start').value);
      const viewportSize = parseInt(document.getElementById('viewport-size').value);
      primary.Viewport.set(viewportStart, viewportSize);
    });
    document.getElementById("file-input").addEventListener("change", () => {
      const file = document.getElementById("file-input").files[0];
      const nBytes = file.size;
      const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
      let sOutput = "";
      for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
        sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
      }
      document.getElementById("fileSize").innerHTML = "File size: " + (sOutput || (nBytes + " bytes"));
      document.getElementById("file-loader-buttons").classList.remove('hidden');
    }, false);
    document.getElementById('load-file-naive').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }

      const t0 = performance.now();
      const text = await f.text();
      const t1 = performance.now();
      console.log(`[Naive] Read file to text: ${(t1 - t0).toFixed(2)}ms`);

      const t2 = performance.now();
      primary.Model.text = text;
      const t3 = performance.now();
      const lineCount = primary.Model.lines.length;
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      console.log(`[Naive] Set Model.text (split + render): ${(t3 - t2).toFixed(2)}ms`);
      console.log(`[Naive] Loaded ${lineCount.toLocaleString()} lines in ${(t3 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
    });

    document.getElementById('load-file-chunked').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }

      const t0 = performance.now();

      // Reset the model to start fresh
      primary.Model.lines = [];

      const CHUNK_SIZE = 1 * 1024 * 1024; // 1MB byte chunks
      let offset = 0;
      let remainder = '';
      let totalLines = 0;

      while (offset < f.size) {
        // Slice file into chunks
        const blob = f.slice(offset, offset + CHUNK_SIZE);
        const text = await blob.text();

        // Prepend any partial line from the previous chunk
        const fullText = remainder + text;

        // Find the last newline in this chunk
        const lastNewlineIndex = fullText.lastIndexOf('\n');

        if (lastNewlineIndex !== -1) {
          // Extract complete lines
          const completeText = fullText.substring(0, lastNewlineIndex);
          const lines = completeText.split('\n');

          // Append to model
          primary.Model.appendLines(lines);
          totalLines += lines.length;

          // Save the remainder for next iteration
          remainder = fullText.substring(lastNewlineIndex + 1);
        } else {
          // No newline found, accumulate to remainder
          remainder = fullText;
        }

        offset += CHUNK_SIZE;
      }

      // Don't forget the last line if there's a remainder
      if (remainder.length > 0) {
        primary.Model.appendLines([remainder]);
        totalLines++;
      }

      const t1 = performance.now();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      console.log(`[Chunked] Loaded ${totalLines.toLocaleString()} lines in ${(t1 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
    });

    document.getElementById('load-file-filereader').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }

      const t0 = performance.now();

      // Reset the model to start fresh
      primary.Model.lines = [];

      const CHUNK_SIZE = 1 * 1024 * 1024; // 1MB byte chunks
      let offset = 0;
      let remainder = '';
      let totalLines = 0;

      // Helper to read blob using FileReader (callback-based API)
      function readBlobAsText(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(e);
          reader.readAsText(blob);
        });
      }

      while (offset < f.size) {
        // Slice file into chunks
        const blob = f.slice(offset, offset + CHUNK_SIZE);
        const text = await readBlobAsText(blob);

        // Prepend any partial line from the previous chunk
        const fullText = remainder + text;

        // Find the last newline in this chunk
        const lastNewlineIndex = fullText.lastIndexOf('\n');

        if (lastNewlineIndex !== -1) {
          // Extract complete lines
          const completeText = fullText.substring(0, lastNewlineIndex);
          const lines = completeText.split('\n');

          // Append to model
          primary.Model.appendLines(lines);
          totalLines += lines.length;

          // Save the remainder for next iteration
          remainder = fullText.substring(lastNewlineIndex + 1);
        } else {
          // No newline found, accumulate to remainder
          remainder = fullText;
        }

        offset += CHUNK_SIZE;
      }

      // Don't forget the last line if there's a remainder
      if (remainder.length > 0) {
        primary.Model.appendLines([remainder]);
        totalLines++;
      }

      const t1 = performance.now();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      console.log(`[FileReader] Loaded ${totalLines.toLocaleString()} lines in ${(t1 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
    });

    document.getElementById('load-file-stream').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }

      const t0 = performance.now();

      // Reset the model to start fresh
      primary.Model.lines = [];

      let remainder = '';
      let totalLines = 0;
      const decoder = new TextDecoder('utf-8');

      // Use ReadableStream to process file chunks
      const stream = f.stream();
      const reader = stream.getReader();

      let chunkCount = 0;

      try {
        while (true) {
          const { done, value } = await reader.read();

          if (done) break;

          // Decode the Uint8Array chunk to text
          const text = decoder.decode(value, { stream: true });

          // Prepend any partial line from the previous chunk
          const fullText = remainder + text;

          // Find the last newline in this chunk
          const lastNewlineIndex = fullText.lastIndexOf('\n');

          if (lastNewlineIndex !== -1) {
            // Extract complete lines
            const completeText = fullText.substring(0, lastNewlineIndex);
            const lines = completeText.split('\n');

            // Append to model
            primary.Model.appendLines(lines);
            totalLines += lines.length;

            // Save the remainder for next iteration
            remainder = fullText.substring(lastNewlineIndex + 1);
          } else {
            // No newline found, accumulate to remainder
            remainder = fullText;
          }

          // Yield to browser every 10 chunks to allow UI updates
          chunkCount++;
          if (chunkCount % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        // Don't forget the last line if there's a remainder
        if (remainder.length > 0) {
          primary.Model.appendLines([remainder]);
          totalLines++;
        }

        const t1 = performance.now();
        const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
        console.log(`[Stream] Loaded ${totalLines.toLocaleString()} lines in ${(t1 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
      } finally {
        reader.releaseLock();
      }
    });

    document.getElementById('load-file-stream-materialized').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }
      const reader = f.stream().getReader();
      try {
        primary.Model.lines = [];
        const decoder = new TextDecoder('utf-8');
        let chunkCount = 0;

        const t0 = performance.now();

        let remainder = '';

        while (true) {
          const { done, value } = await reader.read();

          if (done) break;

          // Decode the Uint8Array chunk to text
          const text = decoder.decode(value, { stream: true });

          // Find the last newline in this chunk
          const lastNewlineIndex = text.lastIndexOf('\n');
          if (lastNewlineIndex !== -1) {
            // Split everything - last element is the incomplete line
            const allLines = text.split('\n');
            const slicedLines = allLines.slice(0, -1);  // All complete lines
            slicedLines[0] = remainder + [0];
            remainder = allLines[allLines.length - 1];  // Incomplete line (remainder)

            // Force materialization using Array.from to break sliced string references
            const materializedLines = slicedLines.map(line => Array.from(line).join(''));
            // Append to model WITHOUT rendering (massive speedup)
            primary.Model.appendLines(materializedLines, true);
          } else {
            remainder += text;
          }

          // Yield to browser every 10 chunks to allow UI updates
          chunkCount++;
          if (chunkCount % 10 === 0) {
            primary.Model.appendLines([], false);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        // Final render
        primary.Model.appendLines(remainder.length > 0 ? ['' + remainder] : [], false);

        const t1 = performance.now();
        const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
        console.log(`[Stream+Mat] Loaded ${primary.Model.lines.length} lines in ${(t1 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
      } finally {
        reader.releaseLock();
      }
    });

   document.getElementById('load-file-stream-materialized-gc').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }
      const reader = f.stream().getReader();
      try {
        primary.Model.lines = [];
        const decoder = new TextDecoder('utf-8');
        let chunkCount = 0;

        const t0 = performance.now();

        let remainder = '';

        while (true) {
          const { done, value } = await reader.read();

          if (done) break;

          // Decode the Uint8Array chunk to text
          const text = decoder.decode(value, { stream: true });

          // Find the last newline in this chunk
          const lastNewlineIndex = text.lastIndexOf('\n');
          if (lastNewlineIndex !== -1) {
            // Split everything - last element is the incomplete line
            const allLines = text.split('\n');
            const slicedLines = allLines.slice(0, -1);  // All complete lines
            slicedLines[0] = remainder + [0];
            remainder = allLines[allLines.length - 1];  // Incomplete line (remainder)

            // Force materialization using Array.from to break sliced string references
            const materializedLines = slicedLines.map(line => Array.from(line).join(''));
            // Append to model WITHOUT rendering (massive speedup)
            primary.Model.appendLines(materializedLines, chunkCount % 10 == 5 ? false : true);
          } else {
            remainder += text;
          }

          // Yield to browser every 10 chunks to allow UI updates
          chunkCount++;
          if (chunkCount % 10 === 0) {
            // Create temporary memory pressure to hint GC
            const _ = new Array(100000);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        // Final render
        primary.Model.appendLines(remainder.length > 0 ? ['' + remainder] : [], false);

        const t1 = performance.now();
        const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
        console.log(`[Stream+Mat] Loaded ${primary.Model.lines.length} lines in ${(t1 - t0).toFixed(2)}ms // ${fileSizeMiB} MiB (${f.size} bytes)`);
      } finally {
        reader.releaseLock();
      }
    });

    document.getElementById('load-file-chunked-compressed').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
        return;
      }

      const reader = f.stream().getReader();
      try {
        primary.Model.activateChunkMode();
        document.getElementById('read-only-indicator').classList.remove('hidden');

        const decoder = new TextDecoder('utf-8');
        let chunkCount = 0;
        const t0 = performance.now();
        let remainder = '';
        let originalSize = 0;
        let compressedSize = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const text = decoder.decode(value, { stream: true });
          const lastNewlineIndex = text.lastIndexOf('\n');

          if (lastNewlineIndex !== -1) {
            const allLines = text.split('\n');
            const slicedLines = allLines.slice(0, -1);
            slicedLines[0] = remainder + slicedLines[0];
            remainder = allLines[allLines.length - 1];

            // Materialize to break string references
            const materializedLines = slicedLines.map(line => Array.from(line).join(''));
            originalSize += materializedLines.join('\n').length;
            await primary.Model.appendLines(materializedLines, true);
          } else {
            remainder += text;
          }

          chunkCount++;
          if (chunkCount % 10 === 0) {
            await primary.Model.appendLines([], false); // Trigger render
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        // Handle final remainder
        if (remainder.length > 0) {
          await primary.Model.appendLines([remainder], false);
        }

        // Calculate compressed size
        for (const chunk of primary.Model.chunks) {
          compressedSize += chunk.length;
        }

        const t1 = performance.now();
        const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
        const compressionRatio = ((1 - compressedSize / originalSize) * 100).toFixed(1);

        compressedFileLoaderLogger(`[Chunked+Compressed] Stored ${primary.Model.totalLines.toLocaleString()} lines in ${primary.Model.chunks.length} gzipped chunks`);
        compressedFileLoaderLogger(`  Time: ${(t1 - t0).toFixed(2)}ms // File: ${fileSizeMiB} MiB (${f.size} bytes)`);
        compressedFileLoaderLogger(`  Original size: ${(originalSize / 1024 / 1024).toFixed(2)} MiB`);
        compressedFileLoaderLogger(`  Compressed size: ${(compressedSize / 1024 / 1024).toFixed(2)} MiB`);
        compressedFileLoaderLogger(`  Compression ratio: ${compressionRatio}% savings`);
        compressedFileLoaderLogger(`  Memory savings: ${primary.Model.chunks.length} chunks vs ${primary.Model.totalLines.toLocaleString()} array elements = ${(primary.Model.totalLines / primary.Model.chunks.length).toFixed(0)}x reduction`);
      } finally {
        reader.releaseLock();
      }
    });

    fetch("docs/instructions.txt")
      .then(response => response.text())
      .then(source => primary.Model.text = source)
      .catch(err => console.error("Error reading instructions.txt:", err));

    fetch("docs/devlog.txt")
      .then(response => response.text())
      .then(source => notes.Model.text = source)
      .catch(err => console.error("Error reading devlog.txt:", err));

    // Fetch Hacker News as plaintext
    async function fetchHackerNewsText() {
      const response = await fetch('https://hacker-news.firebaseio.com/v0/topstories.json');
      const storyIds = await response.json();

      // Get top 30 stories
      const stories = await Promise.all(
        storyIds.slice(0, 30).map(async (id) => {
          const storyRes = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`);
          return storyRes.json();
        })
      );

      // Format as plaintext
      const plaintext = stories
        .map((story, i) => {
          const title = story.title || 'No title';
          const url = story.url || `https://news.ycombinator.com/item?id=${story.id}`;
          const points = story.score || 0;
          const comments = story.descendants || 0;
          return `${i + 1}. ${title}\n   ${url}\n   ${points} points | ${comments} comments\n`;
        })
        .join('\n');

      return plaintext;
    }

    fetchHackerNewsText()
      .then(text => hackernews.Model.text = text)
      .catch(err => console.error("Error fetching Hacker News:", err));

    // Star Wars ASCII Movie Player - Load full movie from sw.txt
    let movieData = null;

    async function loadStarWarsMovie() {
      try {
        const response = await fetch('sw.txt');
        // TODO: We aren't escape the ' character correctly. so \' shows literally .
        movieData = await response.text();
        // Parse frames from movie data
        const rawFrames = movieData.split('\\n'); // Split on literal \n string
        const LINES_PER_FRAME = 14;
        frames = [];

        for (let i = 0; i < rawFrames.length; i += LINES_PER_FRAME) {
          const metadata = rawFrames[i]
          const numFrames = parseInt(metadata);
          const frame = rawFrames.slice(i+1, i + LINES_PER_FRAME).join('\n');
          if(frame.trim()) {
            for(let i = 0; i < numFrames; i++) {
              frames.push(frame);
            }
          }
        }

        document.getElementById('frame-slider').max = frames.length - 1;
        currentFrame = 750;
        showFrame(750);
      } catch (err) {
        console.error("Error loading Star Wars movie:", err);
        starwars.Model.text = "Error loading movie. Check that sw.txt is in the same directory.";
      }
    }

    const LINES_PER_FRAME = 14;
    let frames = [];
    let currentFrame = 0;
    let isPlaying = false;
    let frameInterval = null;
    let frameDelay = 120;

    function showFrame(frameIndex) {
      if (frames.length > 0) {
        starwars.Model.text = frames[frameIndex % frames.length];
        document.getElementById('frame-counter').textContent = `${frameIndex + 1} / ${frames.length}`;
        document.getElementById('frame-slider').value = frameIndex;
      }
    }

    function playMovie() {
      if (isPlaying) return;
      isPlaying = true;
      document.getElementById('play-pause-btn').textContent = 'Pause';

      frameInterval = setInterval(() => {
        showFrame(currentFrame);
        currentFrame = (currentFrame + 1) % frames.length;
      }, frameDelay);
    }

    function pauseMovie() {
      isPlaying = false;
      document.getElementById('play-pause-btn').textContent = 'Play';
      if (frameInterval) {
        clearInterval(frameInterval);
        frameInterval = null;
      }
    }


    // Controls
    document.getElementById('play-pause-btn').addEventListener('click', () => {
      if (isPlaying) {
        pauseMovie();
      } else {
        playMovie();
      }
    });

    document.getElementById('speed-slider').addEventListener('input', (e) => {
      frameDelay = parseInt(e.target.value);
      document.getElementById('speed-value').textContent = frameDelay + 'ms';
      if (isPlaying) {
        pauseMovie();
        playMovie();
      }
    });

    document.getElementById('frame-slider').addEventListener('input', (e) => {
      currentFrame = parseInt(e.target.value);
      showFrame(currentFrame);
    });

    // Load and show movie
    loadStarWarsMovie();

    // Autoplay when scrolled into view
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !isPlaying && frames.length > 0) {
          playMovie();
          observer.unobserve(starWarsElement); // Only autoplay once
        }
      });
    }, { threshold: 0.5 });

    observer.observe(starWarsElement);

    // Matrix Effect Animation
    const MATRIX_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%^&*()_+-=[]{}|;:,.<>?/~`';
    const MATRIX_COLS = 80;
    const MATRIX_ROWS = 20;
    let matrixColumns = [];

    // Initialize columns with random starting positions
    for (let i = 0; i < MATRIX_COLS; i++) {
      matrixColumns.push({
        y: Math.floor(Math.random() * MATRIX_ROWS),
        speed: Math.random() * 0.5 + 0.3, // Random speed between 0.3 and 0.8
        chars: Array(MATRIX_ROWS).fill(' ')
      });
    }

    function updateMatrix() {
      const lines = [];

      // Update each column
      matrixColumns.forEach((col, colIndex) => {
        // Move column down
        col.y += col.speed;

        // Reset to top if reached bottom
        if (col.y > MATRIX_ROWS + 10) {
          col.y = -Math.random() * 10;
          col.speed = Math.random() * 0.5 + 0.3;
        }

        // Add new character at head position
        const headRow = Math.floor(col.y);
        if (headRow >= 0 && headRow < MATRIX_ROWS) {
          col.chars[headRow] = MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
        }

        // Fade out trailing characters
        for (let row = 0; row < MATRIX_ROWS; row++) {
          if (row < headRow - 15) {
            col.chars[row] = ' ';
          } else if (Math.random() < 0.05) {
            // Randomly change some characters for glitch effect
            col.chars[row] = MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
          }
        }
      });

      // Build the display grid
      for (let row = 0; row < MATRIX_ROWS; row++) {
        let line = '';
        for (let col = 0; col < MATRIX_COLS; col++) {
          line += matrixColumns[col].chars[row];
        }
        lines.push(line);
      }

      matrix.Model.text = lines.join('\n');
    }

    // Start Matrix animation
    setInterval(updateMatrix, 50); // Update every 50ms

    // Conway's Game of Life Implementation
    const CONWAY_COLS = 80;
    const CONWAY_ROWS = 30;
    let conwayGrid = [];
    let conwayPlaying = false;
    let conwayInterval = null;
    let conwayDelay = 200;

    // Initialize grid with random pattern
    function initConwayGrid() {
      conwayGrid = [];
      for (let row = 0; row < CONWAY_ROWS; row++) {
        conwayGrid[row] = [];
        for (let col = 0; col < CONWAY_COLS; col++) {
          // Create some interesting starting patterns
          conwayGrid[row][col] = Math.random() < 0.25 ? 1 : 0;
        }
      }

      // Add a glider in the top-left
      if (CONWAY_ROWS > 5 && CONWAY_COLS > 5) {
        conwayGrid[1][2] = 1;
        conwayGrid[2][3] = 1;
        conwayGrid[3][1] = 1;
        conwayGrid[3][2] = 1;
        conwayGrid[3][3] = 1;
      }
    }

    // Count living neighbors
    function countNeighbors(row, col) {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const newRow = (row + dr + CONWAY_ROWS) % CONWAY_ROWS;
          const newCol = (col + dc + CONWAY_COLS) % CONWAY_COLS;
          count += conwayGrid[newRow][newCol];
        }
      }
      return count;
    }

    // Update game state
    function updateConway() {
      const newGrid = [];

      // Apply Conway's rules
      for (let row = 0; row < CONWAY_ROWS; row++) {
        newGrid[row] = [];
        for (let col = 0; col < CONWAY_COLS; col++) {
          const neighbors = countNeighbors(row, col);
          const alive = conwayGrid[row][col];

          if (alive) {
            // Cell is alive
            newGrid[row][col] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            // Cell is dead
            newGrid[row][col] = (neighbors === 3) ? 1 : 0;
          }
        }
      }

      conwayGrid = newGrid;
      renderConway();
    }

    // Render grid to editor
    function renderConway() {
      const lines = [];
      for (let row = 0; row < CONWAY_ROWS; row++) {
        let line = '';
        for (let col = 0; col < CONWAY_COLS; col++) {
          line += conwayGrid[row][col] ? 'â– ' : '.';
        }
        lines.push(line);
      }
      conway.Model.text = lines.join('\n');
    }

    // Play/pause control
    function playConway() {
      if (conwayPlaying) return;
      conwayPlaying = true;
      document.getElementById('conway-play-pause-btn').textContent = 'Pause';
      conwayInterval = setInterval(updateConway, conwayDelay);
    }

    function pauseConway() {
      conwayPlaying = false;
      document.getElementById('conway-play-pause-btn').textContent = 'Play';
      if (conwayInterval) {
        clearInterval(conwayInterval);
        conwayInterval = null;
      }
    }

    function resetConway() {
      pauseConway();
      initConwayGrid();
      renderConway();
    }

    // Event listeners
    document.getElementById('conway-play-pause-btn').addEventListener('click', () => {
      if (conwayPlaying) {
        pauseConway();
      } else {
        playConway();
      }
    });

    document.getElementById('conway-reset-btn').addEventListener('click', resetConway);

    document.getElementById('conway-speed-slider').addEventListener('input', (e) => {
      conwayDelay = parseInt(e.target.value);
      document.getElementById('conway-speed-value').textContent = conwayDelay + 'ms';
      if (conwayPlaying) {
        pauseConway();
        playConway();
      }
    });

    // Initialize Conway's Game of Life
    initConwayGrid();
    renderConway();

    if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
      const notesEditingArea = notesElement.querySelector('.wb-lines');
   
      // Use contenteditable so tapping opens the keyboard
      editor.setAttribute('contenteditable', 'true');
      editor.setAttribute('role', 'textbox');
      editor.setAttribute('aria-multiline', 'true');
      editor.setAttribute('spellcheck', 'false');
      editor.setAttribute('autocapitalize', 'off');
      editor.setAttribute('autocorrect', 'off');
      editor.setAttribute('inputmode', 'text');

      // ---------- iOS adapter: hidden textarea "input sink" ----------
      const sink = document.createElement('textarea');
      sink.setAttribute('autocapitalize', 'off');
      sink.setAttribute('autocorrect', 'off');
      sink.setAttribute('spellcheck', 'false');
      Object.assign(sink.style, {
        position: 'fixed',
        opacity: 0,
        left: '0',
        top: '0',
        height: '1px',
        width: '1px',
      });
      // Fake out a deletion event so iOS fires deleteContentBackward input time
      // Otherwise the keyboard handler with a synthetic Backspace event is never claled.
      const L = '\u200B';           // left sentinel (zero-width space)
      const R = '\u200B';           // right sentinel (optional, helps if you add ForwardDelete later)
      sink.value = L + R ;
      document.body.appendChild(sink);
      function resetSink() {
        sink.value = L + R;                 // always 2 chars
        sink.selectionStart = sink.selectionEnd = 1; // caret between L and R
      }

      // Measure 1ch using the div's font (reliable across browsers)
      function measureChWidth() {
        // Fast path using CSS 1ch
        const probe = document.createElement('span');
        probe.textContent = '0';
        // Match the target divâ€™s font & letter spacing
        const cs = getComputedStyle(notesEditingArea);
        probe.style.font = cs.font;
        probe.style.letterSpacing = cs.letterSpacing;
        probe.style.visibility = 'hidden';
        probe.style.position = 'absolute';
        probe.style.whiteSpace = 'pre';
        document.body.appendChild(probe);
        const w = probe.getBoundingClientRect().width;
        document.body.removeChild(probe);
        return w;
      }
      let ch = measureChWidth();
      // Recompute on font changes / resize (optional but nice)
      new ResizeObserver(() => { ch = measureChWidth(); }).observe(notesEditingArea);

      function getPoint(evt) {
        const rect = notesEditingArea.getBoundingClientRect();
        const touch = evt.changedTouches?.[0] ?? evt.touches?.[0];
        const clientX = touch ? touch.clientX : evt.clientX;
        const clientY = touch ? touch.clientY : evt.clientY;
        // position inside content box, including scroll offset
        // (rect gives viewport coords; add scroll to get content coords)
        const x = (clientX - rect.left) + notesEditingArea.scrollLeft;
        const y = (clientY - rect.top)  + notesEditingArea.scrollTop;
        // subtract padding so (0,0) = top-left of text content, not the padding
        const cs = getComputedStyle(notesEditingArea);
        const padL = parseFloat(cs.paddingLeft)  || 0;
        const padT = parseFloat(cs.paddingTop)   || 0;
        return { x: x - padL, y: y - padT };
      }

      function setCursor(evt) {
        const { x, y } = getPoint(evt);
        const row = Math.max(0, Math.floor(y / 24));
        const col = Math.max(0, Math.floor(x / ch));
        notes.Selection.iosSetCursorAndRender({ row, col });
      }

      // Map beforeinput â†’ synthetic keydown(s)
      sink.addEventListener('beforeinput', (e) => {
        // We consume the DOM change; weâ€™ll notify the editor via keydown.
        e.preventDefault();

        if(e.inputType === 'insertText') {
          for (const ch of e.data || '') synthKeydown(ch);
        } else if (e.inputType === 'deleteContentBackward') {
          synthKeydown('Backspace');
        } else if (e.inputType === 'insertLineBreak') {
          synthKeydown('Enter');
        }
        resetSink(); // <- ALWAYS restore Lâ€¢R with caret in the middle
      });
      // IME/dictation: commit composed text as keydowns
      sink.addEventListener('compositionend', (e) => {
        if (e.data) {
          for (const ch of e.data) synthKeydown(ch);
        }
      });
      // Helper: dispatch a synthetic keydown into your editor
      function synthKeydown(key) {
        // Use only what your handler needs; e.key is the important bit.
        const ev = new KeyboardEvent('keydown', {
          key,
          bubbles: true,
          cancelable: true,
          // Best-effort code; fine if it's not perfect for non-letters.
          code: key.length === 1 ? ('Key' + key.toUpperCase()) : key
        });
        // Some code checks isTrusted; this wonâ€™t be trusted, so avoid that check.
        editor.dispatchEvent(ev);
      }

      // Focus on tap (otherwise iOS may not show keyboard)
      // Focus the sink on tap so iOS shows the keyboard.
      editor.addEventListener('pointerdown', e => {
        sink.focus({preventScroll: true});
        setCursor(e);
      });
    }
  });
</script>
</body>
</html>
