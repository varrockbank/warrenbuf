<html>
<head>
<script src="warrenbuf.js"></script>
<style>
  /************* "Atomic CSS" classes for Boxes *************/
  .💪 { display: flex }                                 /* Flex like muscles.   */
  .🥷 { overflow: hidden }
  .🪜 { flex-flow: column }
  .🌳 { flex: 1 }                                       /* Grow like a tree.    */
  .🦠 { justify-content: space-between }                /* Stay spread apart.   */

  body {
      background-color: #494460;
      color: white;
  }
  blockquote {
      margin: 15px;
  }
  /*** Classes for WarrenBuf ***/
  .wb {
      background-color: #282C34;
      color: #B2B2B2;
      position: relative;
      outline: none;
      font-family: monospace;
      border: 1px solid black;
  }
  .no-select {
      user-select: none;       /* Standard */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none;    /* Firefox */
      -ms-user-select: none;     /* IE/Edge (old) */
  }
  /* Bridge must be selectable but invisible & offscreen */
  .wb-clipboard-bridge {
      position: fixed;      /* out of normal flow so it won't jump layout */
      left: 0;
      top: 1px;
      width: 0;
      height: 1px;
      opacity: 0;
      pointer-events: none; /* avoid clicks */
  }

  .wb .wb-lines>pre::before {
      content: "\200B";
  }
  .wb .wb-lines pre {
      margin: 0;
      overflow: hidden;
  }
  .wb .wb-selection {
      left: 0ch;
      top: 0ch;
      background-color: #EDAD10;
      position: absolute;
      mix-blend-mode: difference;        /* inverts underlying pixels */
  }
  .wb .wb-status span {
      padding-right: 4px;
  }
  .wb .wb-lines pre .highlight-function {
      color: orange;
  }
  .wb .wb-lines pre .highlight-function-name {
      color: cadetblue ;
  }
  .wb .wb-lines pre .highlight-string {
      color: green;
  }
</style>
</head>

<body>
<details>
  <summary>Diagnostics</summary>
  <label for="viewport-start">Viewport Start: </label>
  <input id="viewport-start" value="0"></input>
  <label for="viewport-size">Viewport Size:</label>
  <input id="viewport-size" value="10"></input>
  <button id="viewport-update">Update viewport</button>
  <button id="viewport-scroll-up-1">Scroll -1</button>
  <button id="viewport-scroll-down-1">Scroll +1</button>
  <hr />
  <input id="file-input" type="file" name="myFiles">
  total size: <span id="fileSize">0</span>
  <div>
    <button id="load-file">Load File</button>
  </div>
  <div>
    <button id="append-file">Append File</button><br />
    Append at Line number: <input id="append-at-line" value="1"></input>
  </div>
</details>
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="playground">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
      <div class="💪">
          <div class="wb-gutter"></div>
          <div class="wb-lines 🌳 🥷"></div>
      </div>
      <div class="💪 wb-status 🦠">
          <div class="wb-status-left 💪">
              <span class="wb-linecount"></span>
          </div>
          <div class="wb-status-right 💪">
              <span class="wb-coordinate"></span>
              <span>|</span>
              <span class="wb-indentation"></span>
          </div>
      </div>
  </blockquote>
  <h2>This second editor has iOS support enabled</h2>
  <blockquote cite="" class="💪 🍜 🥷 🌕 🪜 wb no-select" tabindex="0" id="notes">
    <!-- Hidden clipboard bridge lives inside the editor so copy bubbles through it -->
    <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="💪">
      <div class="wb-gutter"></div>
      <div class="wb-lines 🌳 🥷"></div>
    </div>
    <div class="💪 wb-status 🦠">
      <div class="wb-status-left 💪">
        <span class="wb-linecount"></span>
      </div>
      <div class="wb-status-right 💪">
        <span class="wb-coordinate"></span>
        <span>|</span>
        <span class="wb-indentation"></span>
      </div>
    </div>
  </blockquote>
  <script type="module">
    import { Parser, Language, Query } from "https://cdn.jsdelivr.net/npm/web-tree-sitter@0.25.10/tree-sitter.js";

    await Parser.init(); // loads tree-sitter.wasm from the same CDN path
    const treesitterParser = new Parser();
    const javascriptParser = await Language.load(
      "https://cdn.jsdelivr.net/npm/tree-sitter-wasms@0.1.12/out/tree-sitter-javascript.wasm"
    );
    treesitterParser.setLanguage(javascriptParser);
    const highlightQuery = `
      (function_declaration name: (identifier) @function)
      (string) @string
    `;
    const query = new Query(javascriptParser, highlightQuery);
    
    window.treesitterInstance = {
       query,
       parser: treesitterParser 
    };

</script>
<script>
  window.addEventListener("DOMContentLoaded", () => {

    const mainElement = document.getElementById("playground");
    const primary = new WarrenBuf(mainElement, null, null);
    // primary.Model.text = "This is my first text document\nWoohoo\nFoobar\njfdhfjhfdg\njfdhj\ndh";
    mainElement.focus();
    window.primary = primary;

    const notesElement = document.getElementById('notes');
    const notes = new WarrenBuf(notesElement, null, null, 20);

    // Diagnostics -- Bind UI controls to move viewport
    document.getElementById('viewport-update').addEventListener('click', () => {
      const viewportStart = parseInt(document.getElementById('viewport-start').value);
      const viewportSize = parseInt(document.getElementById('viewport-size').value);
      primary.Viewport.set(viewportStart, viewportSize);
    });
    document.getElementById('viewport-scroll-up-1').addEventListener('click', () => {
      primary.Viewport.scroll(-1);
    });
    document.getElementById('viewport-scroll-down-1').addEventListener('click', () => {
      primary.Viewport.scroll(1);
    });
    document.getElementById("file-input").addEventListener("change", () => {
      const file = this.files[0];
      const nBytes = file.size;
      const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
      let sOutput = "";
      for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
        sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
      }
      document.getElementById("fileSize").innerHTML = sOutput || (nBytes + " bytes");
    }, false);
    document.getElementById('load-file').addEventListener('click', () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
      } else {
        f.text().then(text => primary.Model.text = text)
      }
    });
    document.getElementById('append-file').addEventListener('click', () => {
      const lineNumber = parseInt(document.getElementById('append-at-line').value);
      const f = document.getElementById("file-input").files[0];
      if (!f) {
        alert("No file selected");
      } else {
        f.text().then(text => {
          const s = text.split("\n");
          const t0 = performance.now();
          primary.Model.splice(lineNumber, s);
          const t1 = performance.now();
          console.log(`Took ${parseFloat(t1 - t0).toFixed(2)} millis to splice ${s.length.toLocaleString()} elements at ${index.toLocaleString()} w/ ${primary.Model.lc.toLocaleString()} lines.`);
        });
      }
    });

    fetch("docs/instructions.txt")
      .then(response => response.text())
      .then(source => primary.Model.text = source)
      .catch(err => console.error("Error reading foobar.js:", err));

    fetch("docs/devlog.txt")
      .then(response => response.text())
      .then(source => notes.Model.text = source)
      .catch(err => console.error("Error reading foobar.js:", err));

    if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
      const notesEditingArea = notesElement.querySelector('.wb-lines');
   
      // Use contenteditable so tapping opens the keyboard
      editor.setAttribute('contenteditable', 'true');
      editor.setAttribute('role', 'textbox');
      editor.setAttribute('aria-multiline', 'true');
      editor.setAttribute('spellcheck', 'false');
      editor.setAttribute('autocapitalize', 'off');
      editor.setAttribute('autocorrect', 'off');
      editor.setAttribute('inputmode', 'text');

      // ---------- iOS adapter: hidden textarea "input sink" ----------
      const sink = document.createElement('textarea');
      sink.setAttribute('autocapitalize', 'off');
      sink.setAttribute('autocorrect', 'off');
      sink.setAttribute('spellcheck', 'false');
      Object.assign(sink.style, {
        position: 'fixed',
        opacity: 0,
        left: '0',
        top: '0',
        height: '1px',
        width: '1px',
      });
      // Fake out a deletion event so iOS fires deleteContentBackward input time
      // Otherwise the keyboard handler with a synthetic Backspace event is never claled.
      const L = '\u200B';           // left sentinel (zero-width space)
      const R = '\u200B';           // right sentinel (optional, helps if you add ForwardDelete later)
      sink.value = L + R ;
      document.body.appendChild(sink);
      function resetSink() {
        sink.value = L + R;                 // always 2 chars
        sink.selectionStart = sink.selectionEnd = 1; // caret between L and R
      }

      // Measure 1ch using the div's font (reliable across browsers)
      function measureChWidth() {
        // Fast path using CSS 1ch
        const probe = document.createElement('span');
        probe.textContent = '0';
        // Match the target div’s font & letter spacing
        const cs = getComputedStyle(notesEditingArea);
        probe.style.font = cs.font;
        probe.style.letterSpacing = cs.letterSpacing;
        probe.style.visibility = 'hidden';
        probe.style.position = 'absolute';
        probe.style.whiteSpace = 'pre';
        document.body.appendChild(probe);
        const w = probe.getBoundingClientRect().width;
        document.body.removeChild(probe);
        return w;
      }
      let ch = measureChWidth();
      // Recompute on font changes / resize (optional but nice)
      new ResizeObserver(() => { ch = measureChWidth(); }).observe(notesEditingArea);

      function getPoint(evt) {
        const rect = notesEditingArea.getBoundingClientRect();
        const touch = evt.changedTouches?.[0] ?? evt.touches?.[0];
        const clientX = touch ? touch.clientX : evt.clientX;
        const clientY = touch ? touch.clientY : evt.clientY;
        // position inside content box, including scroll offset
        // (rect gives viewport coords; add scroll to get content coords)
        const x = (clientX - rect.left) + notesEditingArea.scrollLeft;
        const y = (clientY - rect.top)  + notesEditingArea.scrollTop;
        // subtract padding so (0,0) = top-left of text content, not the padding
        const cs = getComputedStyle(notesEditingArea);
        const padL = parseFloat(cs.paddingLeft)  || 0;
        const padT = parseFloat(cs.paddingTop)   || 0;
        return { x: x - padL, y: y - padT };
      }

      function setCursor(evt) {
        const { x, y } = getPoint(evt);
        const row = Math.max(0, Math.floor(y / 24));
        const col = Math.max(0, Math.floor(x / ch));
        notes.Selection.iosSetCursorAndRender({ row, col });
      }

      // Map beforeinput → synthetic keydown(s)
      sink.addEventListener('beforeinput', (e) => {
        // We consume the DOM change; we’ll notify the editor via keydown.
        e.preventDefault();

        if(e.inputType === 'insertText') {
          for (const ch of e.data || '') synthKeydown(ch);
        } else if (e.inputType === 'deleteContentBackward') {
          synthKeydown('Backspace');
        } else if (e.inputType === 'insertLineBreak') {
          synthKeydown('Enter');
        }
        resetSink(); // <- ALWAYS restore L•R with caret in the middle
      });
      // IME/dictation: commit composed text as keydowns
      sink.addEventListener('compositionend', (e) => {
        if (e.data) {
          for (const ch of e.data) synthKeydown(ch);
        }
      });
      // Helper: dispatch a synthetic keydown into your editor
      function synthKeydown(key) {
        // Use only what your handler needs; e.key is the important bit.
        const ev = new KeyboardEvent('keydown', {
          key,
          bubbles: true,
          cancelable: true,
          // Best-effort code; fine if it's not perfect for non-letters.
          code: key.length === 1 ? ('Key' + key.toUpperCase()) : key
        });
        // Some code checks isTrusted; this won’t be trusted, so avoid that check.
        editor.dispatchEvent(ev);
      }

      // Focus on tap (otherwise iOS may not show keyboard)
      // Focus the sink on tap so iOS shows the keyboard.
      editor.addEventListener('pointerdown', e => {
        sink.focus({preventScroll: true});
        setCursor(e);
      });
    }
  });
</script>
</body>
</html>
